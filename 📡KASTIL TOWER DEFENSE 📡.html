
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kastil Tower Defense v3.0</title>
  <style>
/* Style untuk inventory container scrollable */
#allUnits, #equippedUnits {
  max-height: 200px; /* Atur tinggi ma// Efek dance untuk dancing dan guard
if (this.type === "dancing" || this.type === "guard") {
  // Efek visual dance - mengubah posisi y sedikit agar terlihat seperti melompat
  const now = Date.now();
  const dancePhase = (now % 500) / 500; // 0-1 setiap 0.5 detik
  
  // Simpan posisi asli untuk floating
  if (!this.danceOffset) {
    this.danceOffset = Math.sin(now / 200) * 5;
  } else {
    // Update posisi y untuk efek melompat
    this.danceOffset = Math.sin(now / 200) * 8;
  }
}ksimum */
  overflow-y: auto;
  border: 1px solid #444;
  border-radius: 8px;
  padding: 10px;
  margin: 10px 0;
  background: rgba(0, 0, 0, 0.3);
}

/* Style scrollbar (opsional, untuk tampilan lebih baik) */
#allUnits::-webkit-scrollbar,
#equippedUnits::-webkit-scrollbar {
  width: 8px;
}

#allUnits::-webkit-scrollbar-track,
#equippedUnits::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

#allUnits::-webkit-scrollbar-thumb,
#equippedUnits::-webkit-scrollbar-thumb {
  background: #007bff;
  border-radius: 4px;
}

#allUnits::-webkit-scrollbar-thumb:hover,
#equippedUnits::-webkit-scrollbar-thumb:hover {
  background: #0056b3;
}

/* Tombol Info di pojok kanan atas */
#infoBtn {
  position: absolute;
  top: 20px;
  right: 20px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  font-size: 24px;
  cursor: pointer;
  z-index: 1000;
  transition: transform 0.2s, background 0.2s;
}

#infoBtn:hover {
  background: #0056b3;
  transform: scale(1.1);
}

/* Popup Update Info */
#updatePopup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.8);
  z-index: 2000;
  justify-content: center;
  align-items: center;
}

#updateContent {
  background: linear-gradient(145deg, #1a1a2e, #16213e);
  color: white;
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  border-radius: 15px;
  padding: 20px;
  border: 3px solid #00f0ff;
  box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
  overflow-y: auto;
  position: relative;
}

#closeUpdateBtn {
  position: absolute;
  top: 15px;
  right: 15px;
  background: #ff4444;
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 20px;
  cursor: pointer;
  transition: transform 0.2s;
}

#closeUpdateBtn:hover {
  transform: scale(1.1);
  background: #ff0000;
}

.update-slide {
  display: none;
  padding: 20px;
  text-align: left;
}

.update-slide.active {
  display: block;
  animation: fadeIn 0.5s;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.update-title {
  color: #FFD700;
  font-size: 28px;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

.update-date {
  color: #00f0ff;
  font-size: 16px;
  text-align: center;
  margin-bottom: 20px;
}

.update-content {
  background: rgba(0,0,0,0.3);
  padding: 20px;
  border-radius: 10px;
  margin-bottom: 20px;
  border-left: 4px solid #00f0ff;
}

.update-content h3 {
  color: #4CAF50;
  margin-top: 15px;
  margin-bottom: 10px;
}

.update-content ul {
  padding-left: 20px;
}

.update-content li {
  margin-bottom: 8px;
  line-height: 1.5;
}

.update-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #444;
}

.nav-btn {
  background: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
}

.nav-btn:hover {
  background: #0056b3;
}

.nav-btn:disabled {
  background: #666;
  cursor: not-allowed;
}

.slide-indicator {
  color: #ccc;
  font-size: 14px;
}

.update-emoji {
  font-size: 20px;
  margin-right: 8px;
}

/* Tambahkan di dalam tag <style> */
#gachaBtn {
  padding: 20px;
  font-size: 24px;
  background: linear-gradient(45deg, #FF4081, #E91E63);
  border: none;
  color: white;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 8px;
  transition: background 0.2s, transform 0.2s;
  font-weight: bold;
}

#gachaBtn:hover {
  background: linear-gradient(45deg, #E91E63, #C2185B);
  transform: scale(1.05);
}

/* Style untuk tombol spin */
#spin1xBtn:hover, #spin5xBtn:hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(255, 64, 129, 0.7);
}

/* Style untuk shop items */
#gachaScreen button[onclick^="redeemUnit"]:hover {
  transform: scale(1.05);
  box-shadow: 0 0 10px currentColor;
}

#gachaScreen button[onclick^="redeemUnit"]:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

#achievementBtn {
  padding: 20px;
  font-size: 24px;
  background: #FFD700;  /* warna {emas */
  border: none;
  color: #333;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 8px;
  transition: background 0.2s, transform 0.2s;
  font-weight: bold;
}

#achievementBtn:hover {
  background: #FFC107; /* emas lebih terang */
  transform: scale(1.05);
}
    /* Night mode overlay */
#nightOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.45); /* kegelapan, ubah alfa kalau mau lebih gelap/terang */
  pointer-events: none;
  display: none; /* default off */
  transition: opacity 0.5s ease;
  z-index: 999; /* supaya di atas canvas & UI */
}
 #upgradeBtn.hidden {
  display: none;
}
    #inventoryBtn {
  padding: 20px;
  font-size: 24px;
  background: #8B4513;  /* coklat */
  border: none;
  color: white;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 8px;
  transition: background 0.2s;
}

#inventoryBtn:hover {
  background: #5C3317; /* coklat lebih gelap saat hover */
}

  .map-btn {
  padding: 15px 30px;
  margin: 10px;
  font-size: 20px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  background: #444;
  color: white;
  transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
}

.map-btn:hover {
  background: #666;
}

.map-btn.selected {
  background: #007bff;
  box-shadow: 0 0 15px #00f0ff;
  transform: scale(1.1);
}

  .unit-btn {
  background: #fff;          /* PUTIH dari awal */
  color: #000;               /* teks hitam */
  border: 1px solid #ccc;    /* garis tipis */
  padding: 6px 10px;
  margin: 4px;
  cursor: pointer;
  font-size: 14px;
  border-radius: 6px;
  transition: transform 0.1s, background 0.2s, box-shadow 0.2s;
}

 .unit-btn.god {
  background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
  color: white;
  font-weight: bold;
}

/* efek hover */
.unit-btn:hover {
  background: #eee;          /* abu terang, bukan putih silau */
}

/* hilangkan efek klik putih terang */
.unit-btn:active {
  background: #ddd;          /* abu agak gelap saat ditekan */
  transform: scale(0.95);    /* animasi kecil */
}

/* tombol yang sedang dipilih */
.unit-btn.selected {
  border: 2px solid #00f0ff;  /* garis biru */
  box-shadow: 0 0 8px #00f0ff; /* glow biru */
}

    body { margin: 0; font-family: sans-serif; background: #001f3f; overflow: hidden; }
    #gameCanvas { display: block; margin: auto; background: #222; }
    #waveCounter, #baseInfo, #moneyInfo {
      position: absolute; background: rgba(0,0,0,0.6); color: white;
      padding: 5px 10px; border-radius: 5px; font-size: 18px;
    }
    #waveCounter { top: 10px; left: 10px; }
    #baseInfo { top: 10px; right: 10px; }
    #moneyInfo { top: 40px; right: 10px; }
    #hotbar {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 150px;
      background: rgba(0,0,0,0.85); color: white; padding: 10px; box-sizing: border-box;
    }
    #toggleHotbarBtn {
  position: absolute;
  top: -30px;       /* muncul di atas hotbar */
  left: 50%;
  transform: translateX(-50%);
  background: #444;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
}
#hotbar.collapsed {
  height: 40px;               /* lebih pendek */
}
#hotbar.collapsed .hotbar-content {
  display: none;              /* isi hotbar hilang */
}
    .hotbar-btn {
  background: #444;
  color: white;
  border: none;
  padding: 5px 10px;
  margin-right: 10px;
  cursor: pointer;
    }
    #menu, #gameArea {
      display: none; /* Hide both initially */
      text-align: center;
      color: white;
    }
    #menu { display: flex; flex-direction: column; justify-content: center; height: 100vh; }
    #startBtn,
#endlessBtn {
  padding: 20px;
  font-size: 24px;
  background: #007bff;
  border: none;
  color: white;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 8px;
  transition: background 0.2s;
}

#startBtn:hover,
#endlessBtn:hover {
  background: #0056b3;
}

/* ğŸ”¥ Tombol Inventory sama ukuran tapi coklat */
#inventoryBtn {
  padding: 20px;
  font-size: 24px;
  background: #8B4513;  /* coklat */
  border: none;
  color: white;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 8px;
  transition: background 0.2s;
}

#inventoryBtn:hover {
  background: #5C3317; /* coklat gelap */
}

    .game-title {
  display: inline-block;
  padding: 20px 40px;
  background: linear-gradient(145deg, #222, #333);
  color: #f8f8f8;
  font-size: 40px;
  font-weight: bold;
  border: 3px solid #00f0ff; /* biru neon */
  border-radius: 12px;
  text-shadow: 0 0 10px rgba(0,255,255,0.6), 0 0 20px rgba(0,255,255,0.4);
  box-shadow: 0 0 20px rgba(0,255,255,0.25);
  animation: glowPulse 3s ease-in-out infinite;
  position: relative;
}

.game-title::before,
.game-title::after {
  content: "âš”ï¸";
  font-size: 32px;
  margin: 0 12px;
  position: relative;
  top: 4px;
}

@keyframes glowPulse {
  0%,100% { box-shadow: 0 0 20px rgba(0,255,255,0.25); }
  50%     { box-shadow: 0 0 35px rgba(0,255,255,0.6); }
}

  
#sellBtn:hover {
  background: #ff1a1a; /* merah lebih terang pas hover */
}

  #upgradeBtn {
    background: #28a745; /* hijau */
    color: white;
    border: none;
    padding: 5px 12px;
    cursor: pointer;
    font-weight: bold;
    border-radius: 5px;
    transition: background 0.2s;
  }

  #upgradeBtn:hover {
    background: #34d058; /* hijau lebih terang pas hover */
  }
  

  /* Style untuk tombol Time Stop di atas hotbar */
#timeStopBtn {
  position: absolute;
  top: -35px;
  right: 10px;
  background: #0066cc;
  color: white;
  border: none;
  padding: 8px 15px;
  cursor: pointer;
  border-radius: 5px;
  font-weight: bold;
  z-index: 1000;
  display: none;
}

/* Style hover untuk tombol Time Stop */
#timeStopBtn:hover {
  background: #0052a3;
}

/* Style saat disabled */
#timeStopBtn:disabled {
  background: #666;
  cursor: not-allowed;
}

/* Style saat active */
#timeStopBtn.active {
  background: #00cc00;
}

/* Responsif untuk layar kecil */
@media (max-width: 768px) {
  #timeStopBtn {
    padding: 6px 12px;
    font-size: 14px;
    top: -30px;
  }
}
  </style>
</head>
<body>
<div id="menu">
  <button id="infoBtn">â„¹ï¸</button>
  <div id="gemDisplay" style="font-size:20px; margin-top:10px;">ğŸ’: 0</div>
  <h1 class="game-title">KASTIL TOWER DEFENSE</h1>
  <button id="startBtn">Start Game</button>
  <button id="endlessBtn">Endless Mode</button>
  <button id="inventoryBtn">ğŸ“¦ Inventory</button> 
  <button id="achievementBtn">ğŸ† Achievement</button>
  <button id="gachaBtn">ğŸ° Gacha ğŸ°</button>
</div>

<!-- Popup Update Info -->
<div id="updatePopup">
  <div id="updateContent">
    <button id="closeUpdateBtn">âœ•</button>
    <h2 style="text-align:center; color:#FFD700; margin-bottom:20px;">ğŸ“œ Riwayat Update ğŸ“œ</h2>
    
    <!-- Slide 0 - Beta -->
    <div class="update-slide active" id="slide0">
      <div class="update-title">ğŸ° Update Beta ğŸ°</div>
      <div class="update-date">(18-11-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Konten Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ—¡ï¸</span> Unit Baru: Sword</li>
          <li><span class="update-emoji">ğŸ‘»</span> Musuh Baru: Ghost</li>
          <li><span class="update-emoji">ğŸ§Ÿâ€â™‚ï¸</span> Musuh Baru: Zombie</li>
        </ul>
        <h3>ğŸ›£ï¸ Sistem Baru:</h3>
        <ul>
          <li>Sistem jalan path untuk musuh</li>
          <li>Mekanika dasar tower defense</li>
          <li>Sistem combat inti</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 1 -->
    <div class="update-slide" id="slide1">
      <div class="update-title">ğŸ° Update 1 ğŸ°</div>
      <div class="update-date">(22-11-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ¹</span> Archer - Penembak jarak jauh</li>
          <li><span class="update-emoji">ğŸ“»</span> Speaker - Penyerang area</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 2 -->
    <div class="update-slide" id="slide2">
      <div class="update-title">ğŸ° Update 2 ğŸ°</div>
      <div class="update-date">(25-11-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Konten Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘¹</span> Musuh Baru: Reog</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ³</span> Unit Baru: Chef</li>
        </ul>
        <h3>ğŸ¯ Sistem Game:</h3>
        <ul>
          <li>Sistem kalah dan menang</li>
          <li>Kondisi win/lose</li>
          <li>Pelacakan skor</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 3 -->
    <div class="update-slide" id="slide3">
      <div class="update-title">ğŸ° Update 3 ğŸ°</div>
      <div class="update-date">(3-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Fitur Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ’</span> Sistem mata uang Diamond</li>
          <li><span class="update-emoji">ğŸ¤¬</span> Musuh Baru: Angry</li>
        </ul>
        <h3>ğŸ“ˆ Progresi Game:</h3>
        <ul>
          <li>Sistem wave 1-50</li>
          <li>Sistem progresi wave</li>
          <li>Peningkatan kesulitan</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 4 -->
    <div class="update-slide" id="slide4">
      <div class="update-title">ğŸ° Update 4 ğŸ°</div>
      <div class="update-date">(7-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Konten Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘ï¸</span> Unit Baru: Eyes (versi lama)</li>
          <li><span class="update-emoji">ğŸƒâ€â™‚ï¸</span> Musuh Baru: Speedrun</li>
          <li><span class="update-emoji">â¤ï¸â€ğŸ”¥</span> Musuh Baru: Hearts</li>
        </ul>
        <h3>âš–ï¸ Perubahan Balance:</h3>
        <ul>
          <li>Nerf Musuh: ğŸ‘¹ Reog - tidak ada skill stun</li>
          <li>Penyesuaian kemampuan musuh</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 5 -->
    <div class="update-slide" id="slide5">
      <div class="update-title">ğŸ° Update 5 ğŸ°</div>
      <div class="update-date">(13-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Penambahan Besar:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ®</span> Menu Utama</li>
          <li><span class="update-emoji">ğŸŒ‹</span> Map Baru: Map 2 (Gunung Berapi)</li>
          <li><span class="update-emoji">â³</span> Unit Baru: Timemage</li>
          <li><span class="update-emoji">â¤ï¸</span> Musuh Baru: Healer</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 6 -->
    <div class="update-slide" id="slide6">
      <div class="update-title">ğŸ° Update 6 ğŸ°</div>
      <div class="update-date">(18-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Konten Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ›¡ï¸</span> Musuh Baru: Shield</li>
          <li><span class="update-emoji">ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦</span> Unit Baru: Lovers</li>
          <li><span class="update-emoji">ğŸŒ€</span> Map Baru: Map 3 (Spiral)</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 7 -->
    <div class="update-slide" id="slide7">
      <div class="update-title">ğŸ° Update 7 ğŸ°</div>
      <div class="update-date">(22-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Organisasi:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘‘</span> Kategori Kastil</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ¦±</span> Kategori Manusia</li>
          <li><span class="update-emoji">âœ¨</span> Kategori Special</li>
        </ul>
        <h3>âš–ï¸ Perubahan Balance:</h3>
        <ul>
          <li>Nerf Unit: ğŸ‘¨â€ğŸ³ Chef</li>
          <li>Buff Unit: ğŸ‘ï¸ Eyes</li>
          <li><span class="update-emoji">ğŸ¥·</span> Musuh Baru: Ninja</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 8 -->
    <div class="update-slide" id="slide8">
      <div class="update-title">ğŸ° Update 8 ğŸ°</div>
      <div class="update-date">(26-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ¦…</span> Falconer - Pemanggil elang</li>
        </ul>
        <h3>âš–ï¸ Penyesuaian Balance:</h3>
        <ul>
          <li>Nerf Unit: ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ Lovers</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 9 -->
    <div class="update-slide" id="slide9">
      <div class="update-title">ğŸ° Update 9 ğŸ°</div>
      <div class="update-date">(29-12-2025)</div>
      <div class="update-content">
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ§šâ€â™‚ï¸</span> Musuh Baru: Furry</li>
          <li><span class="update-emoji">ğŸ€</span> Musuh Baru: LuckyBlock</li>
        </ul>
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘¨â€??</span> Unit Baru: Scientist</li>
        </ul>
        <h3>âš–ï¸ Perubahan Balance:</h3>
        <ul>
          <li>Buff Unit: ğŸ“» Speaker</li>
          <li>Nerf Musuh: â¤ï¸â€ğŸ”¥ Hearts</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 10 -->
    <div class="update-slide" id="slide10">
      <div class="update-title">ğŸ° Update 10 ğŸ°</div>
      <div class="update-date">(3-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Fitur Utama:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ“¦</span> Sistem Inventory</li>
          <li><span class="update-emoji">âˆ</span> Mode Endless</li>
          <li><span class="update-emoji">ğŸ‰</span> Boss Endless: Naga</li>
        </ul>
        <h3>âœ¨ Konten Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ¯</span> Rework Unit: Eyes â†’ Sniper</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ’»</span> Unit Baru: Programmer</li>
          <li><span class="update-emoji">âŒ</span> Map Baru: Map 4</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ«</span> Musuh Baru: Guru</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 11 -->
    <div class="update-slide" id="slide11">
      <div class="update-title">ğŸ° Update 11 ğŸ°</div>
      <div class="update-date">(6-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸŒ¾</span> Farmer - Penghasil uang</li>
          <li><span class="update-emoji">ğŸ’£</span> Bombi - Damage area</li>
          <li><span class="update-emoji">ğŸ”‹</span> Boost - Penguat tower</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ”§</span> Musuh Baru: Engineer</li>
        </ul>
        <h3>âš–ï¸ Balance:</h3>
        <ul>
          <li>Nerf Unit: ğŸ‘¨â€ğŸ”¬ Scientist</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 12 -->
    <div class="update-slide" id="slide12">
      <div class="update-title">ğŸ° Update 12 ğŸ°</div>
      <div class="update-date">(9-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ’˜</span> Cupid - Serangan tembus</li>
          <li><span class="update-emoji">ğŸ°</span> Judi - Efek random</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ•µï¸</span> Musuh Baru: Thief - Mencuri uang</li>
        </ul>
        <h3>ğŸ”„ Perbaikan:</h3>
        <ul>
          <li>Penambahan kategori baru</li>
          <li>Rework Map: ğŸŒ€ Map 3</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 13 -->
    <div class="update-slide" id="slide13">
      <div class="update-title">ğŸ° Update 13 ğŸ°</div>
      <div class="update-date">(13-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ¨</span> Musuh Baru: Art - HP random</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸ­</span> Musuh Baru: Las - Tahan damage</li>
        </ul>
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">â›ª</span> Priest - Penyembuh base</li>
          <li><span class="update-emoji">ğŸ§›â€â™‚ï¸</span> Vampire - Pemanggil</li>
        </ul>
        <h3>ğŸï¸ Map Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ°</span> Map Baru: Map 5 (Kastil)</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 14 -->
    <div class="update-slide" id="slide14">
      <div class="update-title">ğŸ° Update 14 ğŸ°</div>
      <div class="update-date">(16-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ¤¹â€â™‚ï¸</span> Ball - Tembakan triple</li>
          <li><span class="update-emoji">ğŸª¬</span> God - Pemanggil ultimate</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ…</span> Musuh Baru: Santa - Memanggil musuh random</li>
          <li><span class="update-emoji">ğŸ¤“/ğŸ˜ˆ</span> Musuh Baru: Nerd/Bully - Berubah saat HP rendah</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 15 -->
    <div class="update-slide" id="slide15">
      <div class="update-title">ğŸ° Update 15 ğŸ°</div>
      <div class="update-date">(20-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ§œâ€â™‚ï¸</span> Neptun - Penyerang mode ganda</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">â˜£ï¸</span> Musuh Baru: Nuklir - Menghancurkan tower saat mati</li>
        </ul>
        <h3>ğŸï¸ Map Baru:</h3>
        <ul>
          <li><span class="update-emoji">âš”ï¸</span> Map Baru: Map 6 (Pertempuran)</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 16 -->
    <div class="update-slide" id="slide16">
      <div class="update-title">ğŸ° Update 16 ğŸ°</div>
      <div class="update-date">(23-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‡</span> Musuh Baru: Liar - Berubah jadi kuda</li>
          <li><span class="update-emoji">â›„</span> Musuh Baru: Snow - Membelah saat mati</li>
        </ul>
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ”§</span> Wrench - Memanggil turret sementara</li>
        </ul>
        <h3>âœ¨ Fitur Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ”½</span> Fitur Hotbar bisa di-collapse</li>
          <li><span class="update-emoji">ğŸŒ™</span> Night Mode - Wave malam random</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 17 -->
    <div class="update-slide" id="slide17">
      <div class="update-title">ğŸ° Update 17 ğŸ°</div>
      <div class="update-date">(25-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ–¨ï¸</span> Printer - Penghasil uang</li>
          <li><span class="update-emoji">ğŸ›°ï¸</span> Satellite - Penyerang cepat</li>
          <li><span class="update-emoji">ğŸªƒ</span> Capaw - Penyerang boomerang</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">â˜ ï¸</span> Musuh Baru: Necro - Memanggil minion</li>
        </ul>
        <h3>ğŸï¸ Map Baru:</h3>
        <ul>
          <li><span class="update-emoji">â˜¢ï¸</span> Map Baru: Map 7 (Nuklir)</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 18 -->
    <div class="update-slide" id="slide18">
      <div class="update-title">ğŸ° Update 18 ğŸ°</div>
      <div class="update-date">(27-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ”¦</span> Laser - Sinar terus menerus</li>
          <li><span class="update-emoji">ğŸŒ±</span> Plant - Berkembang dengan upgrade</li>
          <li><span class="update-emoji">ğŸ‘®</span> Police - Pemanggil anjing</li>
          <li><span class="update-emoji">ğŸ¤ </span> Koboi - Serangan jarak ganda</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ‘½</span> Musuh Baru: Alien - Melumpuhkan tower</li>
        </ul>
        <h3>ğŸ”„ Perbaikan:</h3>
        <ul>
          <li>Rework layout Menu Hotbar</li>
          <li>Optimasi UI</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 19 -->
    <div class="update-slide" id="slide19">
      <div class="update-title">ğŸ° Update 18 (Part 2) ğŸ°</div>
      <div class="update-date">(29-1-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ²</span> Dadu - Efek random</li>
          <li><span class="update-emoji">ğŸª™</span> Bitcoin - Nilai bertambah seiring waktu</li>
        </ul>
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ›¸</span> Musuh Baru: UFO - Memanggil alien</li>
        </ul>
        <h3>ğŸï¸ Map Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸŒŸ</span> Map Baru: Map 8 (Bintang)</li>
        </ul>
        <h3>âœ¨ Fitur Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ†</span> Sistem Achievement</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 20 -->
    <div class="update-slide" id="slide20">
      <div class="update-title">ğŸ° Update 19 ğŸ°</div>
      <div class="update-date">(1-2-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸª</span> Hook - Menarik musuh mundur</li>
          <li><span class="update-emoji">ğŸª</span> Circus - Memanggil berbagai pemain</li>
          <li><span class="update-emoji">â°</span> Clock - Ability Time Stop</li>
        </ul>
        <h3>ğŸ° Sistem Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ°</span> Sistem Gacha</li>
          <li><span class="update-emoji">ğŸ”’</span> 3 Unit Limited: God, Neptun, Circus</li>
        </ul>
        <h3>ğŸï¸ Map Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸŸª</span> Map Baru: Map 9 (Ungu)</li>
        </ul>
      </div>
    </div>
    
    <!-- Slide 21 -->
    <div class="update-slide" id="slide21">
      <div class="update-title">ğŸ° Update 20 ğŸ°</div>
      <div class="update-date">(5-2-2026)</div>
      <div class="update-content">
        <h3>âœ¨ Musuh Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸš½</span> Toilet - Memanggil poop</li>
          <li><span class="update-emoji">ğŸ’©</span> Poop - Meningkatkan cooldown tower</li>
        </ul>
        <h3>âœ¨ Unit Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ®</span> Console - Ability tembakan manual</li>
          <li><span class="update-emoji">ğŸ‘¨â€ğŸš€</span> Astronaut - Pemanggil bendera & bulan</li>
        </ul>
        <h3>âš–ï¸ Perubahan Balance:</h3>
        <ul>
          <li>Nerf Unit: ğŸ‘® Police - Harga upgrade lebih mahal</li>
          <li>Buff Unit: ğŸ’˜ Cupid - Range diperbesar</li>
        </ul>
        <h3>âœ¨ Fitur Baru:</h3>
        <ul>
          <li><span class="update-emoji">ğŸ“œ</span> Info Update (Popup ini!)</li>
        </ul>
      </div>
    </div>

    <!-- Slide 22 -->
<div class="update-slide" id="slide22">
  <div class="update-title">ğŸ° Update 21 ğŸ°</div>
  <div class="update-date">(12-2-2026)</div>
  <div class="update-content">
    <h3>âœ¨ Unit Baru:</h3>
    <ul>
      <li><span class="update-emoji">ğŸ©</span> Homesweet - Tower multifungsi dengan peluru pink, laser, dan summon cinta</li>
      <li><span class="update-emoji">ğŸ“·</span> Camera - Tower peniru yang bisa menyalin kemampuan unit lain</li>
      <li><span class="update-emoji">âš”ï¸</span> Swordwrath - Penyerang ganda dengan dua tembakan beruntun</li>
    </ul>
    
    <h3>ğŸ˜ˆ Musuh Baru:</h3>
    <ul>
      <li><span class="update-emoji">ğŸ¦¹â€â™€ï¸</span> Duke - Musuh elite yang kebal time stop dan bisa blink teleport</li>
    </ul>
    
    <h3>âš¡ Buff Unit:</h3>
    <ul>
      <li><span class="update-emoji">ğŸ”‹</span> Boost - Sekarang bisa mem-boost lebih banyak jenis unit</li>
      <li><span class="update-emoji">ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦</span> Lovers - Summon memiliki darah yang lebih besar</li>
      <li><span class="update-emoji">â°</span> Clock - Skill Time Stop dipercepat cooldown-nya</li>
    </ul>
  </div>
</div>
    
    <div class="update-nav">
      <button class="nav-btn" id="prevBtn">â—€ï¸ </button>
      <div class="slide-indicator">
        Update <span id="currentSlide">1</span>/<span id="totalSlides">22</span>
      </div>
      <button class="nav-btn" id="nextBtn">â–¶ï¸</button>
    </div>
  </div>
</div>

<!-- Update inventoryScreen -->
<div id="inventoryScreen" style="display:none; text-align:center; color:white; padding:20px; overflow-y:auto; max-height:90vh;">
  <h2>ğŸ“¦ Inventory Unit</h2>
  <p>Pilih maksimal 6 unit untuk dipakai di game</p>
  
  <div style="margin:20px 0;">
    <h3>Semua Unit</h3>
    <div id="allUnits" style="
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin: 10px auto;
      max-width: 800px;
    "></div>
  </div>
  
  <div style="margin:20px 0;">
    <h3>Unit Terpilih (<span id="equippedCount">0</span>/6)</h3>
    <div id="equippedUnits" style="
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin: 10px auto;
      max-width: 800px;
      min-height: 60px;
    "></div>
  </div>

  <button id="saveInventoryBtn" style="
    margin-top:20px; 
    padding:10px 30px; 
    font-size:18px; 
    background:#007bff; 
    color:white; 
    border:none; 
    border-radius:8px; 
    cursor:pointer;
  ">
    âœ… Simpan & Kembali
  </button>
  
  <button onclick="backToMenuFromInventory()" style="
    margin-top:10px; 
    padding:10px 30px; 
    font-size:16px; 
    background:#333; 
    color:white; 
    border:none; 
    border-radius:8px; 
    cursor:pointer;
  ">
    â¬…ï¸ Kembali ke Menu
  </button>
</div>

   <!-- Update achievementScreen -->
<div id="achievementScreen" style="display:none; text-align:center; color:white; padding:20px; overflow-y:auto; max-height:90vh;">
  <h2>ğŸ† Achievement</h2>
  <p>Capai semua achievement untuk menjadi master!</p>
  
  <div id="achievementsList" style="margin:20px; max-width:500px; margin:0 auto; max-height:60vh; overflow-y:auto;">
    <!-- Achievement akan di-generate oleh JavaScript -->
  </div>
  
  <button id="backFromAchievementBtn" style="margin-top:20px; padding:10px 30px; font-size:18px; background:#333; color:white; border:none; border-radius:8px; cursor:pointer;">
    â† Kembali ke Menu
  </button>
</div>

<!-- Update gachaScreen dengan container scrollable -->
<div id="gachaScreen" style="display:none; text-align:center; color:white; padding:20px; overflow-y:auto; max-height:90vh;">
  <h2>ğŸ° Gacha System ğŸ°</h2>
  <p>Ticket Anda: <span id="ticketCount">0</span> ğŸ«</p>
  <p>Diamond: <span id="gachaDiamondCount">0</span> ğŸ’</p>
  
  <div style="margin:30px 0;">
    <button id="spin1xBtn" style="padding:15px 30px; font-size:20px; margin:10px; background:#FF4081; color:white; border:none; border-radius:8px; cursor:pointer;">
      Spin 1x (50ğŸ’)
    </button>
    <button id="spin5xBtn" style="padding:15px 30px; font-size:20px; margin:10px; background:#E91E63; color:white; border:none; border-radius:8px; cursor:pointer;">
      Spin 5x (250ğŸ’)
    </button>
  </div>
  
  <div style="background:rgba(0,0,0,0.7); padding:20px; border-radius:10px; margin:20px auto; max-width:600px;">
    <h3>Rates:</h3>
    <div style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px;">
      <div style="background:rgba(255,215,0,0.3); padding:10px; border-radius:5px;">ğŸª¬ God (1%)</div>
      <div style="background:rgba(0,191,255,0.3); padding:10px; border-radius:5px;">ğŸ§œâ€â™‚ï¸ Neptun (4%)</div>
      <div style="background:rgba(147,112,219,0.3); padding:10px; border-radius:5px;">ğŸª Circus (5%)</div>
      <div style="background:rgba(50,205,50,0.3); padding:10px; border-radius:5px;">ğŸ« 10 ticket (10%)</div>
      <div style="background:rgba(255,165,0,0.3); padding:10px; border-radius:5px;">ğŸ« 5 ticket (20%)</div>
      <div style="background:rgba(255,69,0,0.3); padding:10px; border-radius:5px;">ğŸ« 3 ticket (30%)</div>
      <div style="background:rgba(220,20,60,0.3); padding:10px; border-radius:5px;">ğŸ« 2 ticket (30%)</div>
    </div>
  </div>
  
  <div style="background:rgba(0,0,0,0.7); padding:20px; border-radius:10px; margin:20px auto; max-width:600px;">
    <h3>Redeem Shop (Gunakan Ticket ğŸ«):</h3>
    <div style="display:flex; flex-wrap:wrap; justify-content:center; gap:15px;">
      <div style="background:rgba(255,215,0,0.5); padding:15px; border-radius:8px; text-align:center; min-width:150px;">
        <div style="font-size:24px;">ğŸª¬ God</div>
        <div>Harga: 100 ğŸ«</div>
        <button onclick="redeemUnit('god')" style="margin-top:10px; padding:8px 15px; background:gold; color:black; border:none; border-radius:5px; cursor:pointer;">
          Redeem
        </button>
        <div id="godStatus" style="margin-top:5px; font-size:12px;"></div>
      </div>
      
      <div style="background:rgba(0,191,255,0.5); padding:15px; border-radius:8px; text-align:center; min-width:150px;">
        <div style="font-size:24px;">ğŸ§œâ€â™‚ï¸ Neptun</div>
        <div>Harga: 75 ğŸ«</div>
        <button onclick="redeemUnit('neptun')" style="margin-top:10px; padding:8px 15px; background:dodgerblue; color:white; border:none; border-radius:5px; cursor:pointer;">
          Redeem
        </button>
        <div id="neptunStatus" style="margin-top:5px; font-size:12px;"></div>
      </div>
      
      <div style="background:rgba(147,112,219,0.5); padding:15px; border-radius:8px; text-align:center; min-width:150px;">
        <div style="font-size:24px;">ğŸª Circus</div>
        <div>Harga: 50 ğŸ«</div>
        <button onclick="redeemUnit('circus')" style="margin-top:10px; padding:8px 15px; background:mediumpurple; color:white; border:none; border-radius:5px; cursor:pointer;">
          Redeem
        </button>
        <div id="circusStatus" style="margin-top:5px; font-size:12px;"></div>
      </div>

<div style="background:rgba(255,105,180,0.5); padding:15px; border-radius:8px; text-align:center; min-width:150px;">
  <div style="font-size:24px;">ğŸ© HomeSweet</div>
  <div>Harga: 150 ğŸ«</div>
  <button onclick="redeemUnit('homesweet')" style="margin-top:10px; padding:8px 15px; background:pink; color:black; border:none; border-radius:5px; cursor:pointer;">
    Redeem
  </button>
  <div id="homesweetStatus" style="margin-top:5px; font-size:12px;"></div>
</div>
    </div>
  </div>
  
  <button id="backFromGachaBtn" style="margin-top:30px; margin-bottom:50px; padding:10px 30px; font-size:18px; background:#333; color:white; border:none; border-radius:8px; cursor:pointer;">
    â¬…ï¸ Kembali ke Menu
  </button>
</div>
   
<div id="mapSelect" style="display:none; text-align:center; color:white;">
  <h2>Pilih Map</h2>
  <button class="map-btn" onclick="chooseMode('map1', this)">ğŸ—º Map 1</button>
  <button class="map-btn" onclick="chooseMode('map2', this)">ğŸŒ‹ Map 2</button>
  <button class="map-btn" onclick="chooseMode('map3', this)">ğŸŒ€ Map 3</button>
  <button class="map-btn" onclick="chooseMode('map4', this)">âŒ Map 4</button>
  <button class="map-btn" onclick="chooseMode('map5', this)">ğŸ° Map 5</button>
  <button class="map-btn" onclick="chooseMode('map6', this)">âš”ï¸ Map 6</button>
  <button class="map-btn" onclick="chooseMode('map7', this)">â˜¢ï¸ Map 7</button>
  <button class="map-btn" onclick="chooseMode('map8', this)">ğŸŒŸ Map 8</button>
  <button class="map-btn" onclick="chooseMode('map9', this)">ğŸŸª Map 9</button>

  <div id="modeSelect" style="margin-top:20px; display:none;">
    <h3>Pilih Mode Unit</h3>
    <button onclick="startGame(selectedMap, 'all')">Mode All Unit</button>
    <button onclick="startGame(selectedMap, 'normal')">Mode Normal</button>
  </div>
</div>
   
  <div id="gameArea" style="display:none; text-align:center; position:relative;">
  <canvas id="gameCanvas" width="1024" height="600"></canvas>
  <div id="nightOverlay"></div>

  <!-- Info overlay -->
  <div id="infoOverlay">
    <div id="waveCounter">Wave: 1</div>
    <div id="baseInfo">Base: 500/500</div>
    <div id="moneyInfo">Money: 300</div>
  </div>

  <div id="hotbar">
  <button id="toggleHotbarBtn">ğŸ”½</button>
  <!-- Tombol Time Stop dipindahkan ke sini -->
  <button id="timeStopBtn" style="
    background: #0066cc;
    color: white;
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    font-weight: bold;
    margin-left: 10px;
    display: none;
  ">â° Time Stop</button>

   <!-- Tambahkan di dalam div hotbar, setelah tombol Time Stop -->
<button id="consoleShootBtn" style="
    background: #9C27B0;
    color: white;
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    font-weight: bold;
    margin-left: 10px;
    display: none;
">âœ´ï¸ Tembak Console</button>
  
  <div class="hotbar-content">
    <!-- Pindahkan unitButtons ke sini -->
    <div id="unitButtons" style="
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      margin: 10px 0;
      max-height: 80px;
      overflow-y: auto;
    "></div>
    
    <!-- Bagian kiri -->
    <div style="float:left;">
      <span id="unitInfo">Klik unit untuk info</span>
      <button id="upgradeBtn">Upgrade</button>
      <span id="upgradeCost">Harga Upgrade: -</span>
    </div>

    <!-- Bagian kanan -->
    <div style="float:right;">
      <button id="sellBtn">Sell</button>
    </div>

    <div style="clear:both;"></div>
  </div>
</div>

    <!-- Tambahkan sebelum </body> -->
<div id="categorySidebar" style="
    position: fixed;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 10px;
    border-radius: 10px;
    backdrop-filter: blur(5px);
">
    <button onclick="showUnits('kastil')" style="
        background: #555;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 22px;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    " title="Kastil">ğŸ‘‘</button>
    
    <button onclick="showUnits('manusia')" style="
        background: #555;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 22px;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    " title="Manusia">ğŸ‘¨â€ğŸ¦±</button>
    
    <button onclick="showUnits('unik')" style="
        background: #555;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 22px;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    " title="Unik">ğŸ§©</button>
    
    <button onclick="showUnits('military')" style="
        background: #555;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 22px;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    " title="Military">ğŸª–</button>
    
    <button onclick="showUnits('special')" style="
        background: #555;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 22px;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    " title="Special">âœ¨</button>
</div>

<style>
/* Responsif sidebar */
@media (max-width: 600px) {
    #categorySidebar {
        left: 5px;
        padding: 8px;
        gap: 6px;
    }
    
    #categorySidebar button {
        width: 45px;
        height: 45px;
        font-size: 20px;
        padding: 10px;
    }
}

@media (max-width: 400px) {
    #categorySidebar {
        left: 2px;
        padding: 6px;
        gap: 4px;
    }
    
    #categorySidebar button {
        width: 40px;
        height: 40px;
        font-size: 18px;
        padding: 8px;
    }
}

/* Hover efek */
#categorySidebar button:hover {
    background: #666;
    transform: scale(1.1);
    transition: all 0.2s;
}
</style>

    <div style="clear:both;"></div>
  </div>
</div>

  <div id="retryScreen" style="
  display:none;
  text-align:center;
  color:white;
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  background: rgba(0,0,0,0.85);
  align-items:center;
  justify-content:center;
  flex-direction:column;
">
  <h1>Kamu Kalah!</h1>
  <button id="retryBtn">Retry</button>
</div>

   <!-- Tambahin di dalam body, setelah retryScreen -->
<div id="winScreen" style="
  display:none;
  text-align:center;
  color:white;
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  background: rgba(0,0,0,0.9);
  align-items:center;
  justify-content:center;
  flex-direction:column;
">
  <h1>ğŸ‰ Kamu Menang! ğŸ‰</h1>
  <p>Hadiah: 100ğŸ’</p>
  <button id="menuBtn">Kembali ke Menu</button>
</div>

 <div id="notificationContainer" style="
  position:absolute;
  bottom:120px;
  left:50%;
  transform:translateX(-50%);
  color:white;
  font-size:20px;
  text-align:center;
  pointer-events:none;
"></div>

<script>
let selectedMap = null;
let unitMode = "all"; // default all
let score = 0;  
let highScore = parseInt(localStorage.getItem("endlessHighScore")) || 0;
let lastPathWarning = 0;
let timeStopActive = false;
let timeStopEnd = 0;
let clockSkillCooldown = 0; // Global cooldown untuk semua Clock
let activeConsole = null; // Tower console yang sedang aktif
let consoleCooldown = 0; // Global cooldown untuk console shooting

let mirrors = []; // Array untuk menyimpan semua mirror aktif

function chooseMode(map, btn) {
  selectedMap = map;

  // hapus highlight dari semua tombol map
  document.querySelectorAll(".map-btn").forEach(b => b.classList.remove("selected"));

  // kasih highlight ke tombol yang dipilih
  if (btn) btn.classList.add("selected");

  if (endlessMode) {
  startGame(selectedMap, "normal"); 
} else {
  document.getElementById("modeSelect").style.display = "block";
}
  document.getElementById("gemDisplay").innerText = 
  "ğŸ’: " + diamonds + " | ğŸ† High Score: " + highScore;
}

let equippedUnits = JSON.parse(localStorage.getItem("equippedUnits")) || []; // simpan unit terpilih
const maxEquip = 6;

// tombol inventory
document.getElementById("inventoryBtn").onclick = () => {
  menu.style.display = "none";
  document.getElementById("inventoryScreen").style.display = "block";
  renderInventory();
};

// tombol simpan
document.getElementById("saveInventoryBtn").onclick = () => {
  localStorage.setItem("equippedUnits", JSON.stringify(equippedUnits));
  showNotification("âœ… Inventory disimpan!");
  backToMenuFromInventory();
};

// Fungsi untuk kembali dari inventory
function backToMenuFromInventory() {
  document.getElementById("inventoryScreen").style.display = "none";
  menu.style.display = "flex";
}

// Update renderInventory() untuk menghitung unit terpilih
function renderInventory(){
  const allContainer = document.getElementById("allUnits");
  const eqContainer = document.getElementById("equippedUnits");
  const countDisplay = document.getElementById("equippedCount");
  
  allContainer.innerHTML = "";
  eqContainer.innerHTML = "";

  // gabung semua unit dari unitSets
  let allUnitsList = [];
  for (let cat in unitSets) {
    // Filter unit special yang masih locked
    if (cat === 'special') {
      unitSets[cat].forEach(u => {
        // Cek apakah unit special sudah di-unlock
        if (['god', 'neptun', 'circus', 'homesweet'].includes(u.type)) {
          if (!unlockedUnits[u.type]) {
            return; // Skip unit yang masih locked
          }
        }
        allUnitsList.push(u);
      });
    } else {
      allUnitsList = allUnitsList.concat(unitSets[cat]);
    }
  }

  allUnitsList.forEach(u => {
    const btn = document.createElement("button");
    btn.className = "unit-btn";
    
    // Tambahkan class god untuk unit god
    if (u.type === 'god') {
      btn.classList.add("god");
    }
    
    btn.innerText = `${u.emoji} ${u.type}`;
    
    // Tambahkan tooltip dengan nama unit
    btn.title = `${u.type} - ${u.cost}$`;
    
    if(equippedUnits.includes(u.type)) btn.classList.add("selected");

    btn.onclick = () => {
      if(equippedUnits.includes(u.type)){
        // unequip
        equippedUnits = equippedUnits.filter(x => x !== u.type);
        btn.classList.remove("selected");
      } else {
        // equip kalau masih <6
        if(equippedUnits.length < maxEquip){
          equippedUnits.push(u.type);
          btn.classList.add("selected");
        } else {
          alert("Slot penuh! Maksimal 6 unit.");
        }
      }
      renderInventory();
    };

    allContainer.appendChild(btn);
  });

  // tampilkan equipped
  equippedUnits.forEach(t => {
    const unit = allUnitsList.find(u => u.type === t);
    if (unit) {
      const badge = document.createElement("div");
      badge.style.cssText = `
        background: rgba(0, 123, 255, 0.2);
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 10px 15px;
        margin: 5px;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      `;
      
      badge.innerHTML = `
        <span style="font-size:20px;">${unit.emoji}</span>
        <span>${unit.type}</span>
        <button onclick="unequipUnit('${t}')" style="
          background: #ff4444;
          color: white;
          border: none;
          border-radius: 50%;
          width: 24px;
          height: 24px;
          font-size: 12px;
          cursor: pointer;
          margin-left: 10px;
        ">Ã—</button>
      `;
      
      eqContainer.appendChild(badge);
    }
  });

  // Update count display
  countDisplay.textContent = equippedUnits.length;
}

// Fungsi untuk unequip unit dari equipped list
function unequipUnit(unitType) {
  equippedUnits = equippedUnits.filter(x => x !== unitType);
  renderInventory();
}

document.getElementById('consoleShootBtn').onclick = () => {
  const now = Date.now();
  
  // Cek cooldown global (2 detik)
  if (now < consoleCooldown) {
    const remaining = Math.ceil((consoleCooldown - now) / 1000);
    showNotification(`Console cooldown: ${remaining}s`);
    return;
  }
  
  // Cek apakah ada console yang aktif
  if (!activeConsole) {
    showNotification("Tidak ada Console yang aktif!");
    return;
  }
  
  // Cek apakah console masih ada di towers
  if (!towers.includes(activeConsole)) {
    showNotification("Console telah dihancurkan!");
    activeConsole = null;
    return;
  }
  
  // Cari target dalam range console
  const targets = enemies.filter(e => 
    Math.hypot(e.pos.x - activeConsole.x, e.pos.y - activeConsole.y) < activeConsole.range
  );
  
  if (targets.length === 0) {
    showNotification("Tidak ada target dalam jangkauan!");
    return;
  }
  
  // Hitung damage dengan cek boost
  let dmg = activeConsole.damage;
  
  const activeBoost = towers.find(t =>
    t.type === "boost" &&
    Math.hypot(t.x - activeConsole.x, t.y - activeConsole.y) < t.range
  );
  
  if (activeBoost) {
    const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
    dmg = Math.floor(dmg * bonusMap[activeBoost.level]);
  }
  
  // Tembak semua musuh dalam range
  targets.forEach(target => {
    target.takeDamage(dmg);
    
    // Visual peluru
    bullets.push({ 
      x: activeConsole.x, 
      y: activeConsole.y, 
      target: target, 
      damage: dmg,
      from: activeConsole,
      type: "console"
    });
    
    // Efek visual khusus console
    ctx.beginPath();
    ctx.moveTo(activeConsole.x, activeConsole.y);
    ctx.lineTo(target.pos.x, target.pos.y);
    ctx.strokeStyle = "#9C27B0";
    ctx.lineWidth = 2;
    ctx.stroke();
  });
  
  // Set cooldown global 2 detik
  consoleCooldown = now + 2000;
  
  // Update tombol cooldown
  const consoleBtn = document.getElementById('consoleShootBtn');
  consoleBtn.disabled = true;
  consoleBtn.style.background = '#666';
  consoleBtn.innerText = `âœ´ï¸ CD: 2s`;
  
  showNotification(`ğŸ® Console menembak ${targets.length} target!`);
  
  // Timer untuk reset tombol
  setTimeout(() => {
    consoleBtn.disabled = false;
    consoleBtn.style.background = '#9C27B0';
    consoleBtn.innerText = 'âœ´ï¸ Tembak Console';
  }, 2000);
};

// Update Info Popup System
let currentSlide = 0;
const totalSlides = 23; // Total slides dari Beta to Update 21

// Event listeners untuk tombol info
document.getElementById('infoBtn').onclick = () => {
  document.getElementById('updatePopup').style.display = 'flex';
  showSlide(0);
};

document.getElementById('closeUpdateBtn').onclick = () => {
  document.getElementById('updatePopup').style.display = 'none';
};

document.getElementById('prevBtn').onclick = () => {
  if (currentSlide > 0) {
    showSlide(currentSlide - 1);
  }
};

document.getElementById('nextBtn').onclick = () => {
  if (currentSlide < totalSlides - 1) {
    showSlide(currentSlide + 1);
  }
};

// Fungsi untuk menampilkan slide tertentu
function showSlide(slideIndex) {
  // Sembunyikan semua slide
  const slides = document.querySelectorAll('.update-slide');
  slides.forEach(slide => {
    slide.classList.remove('active');
  });
  
  // Tampilkan slide yang dipilih
  slides[slideIndex].classList.add('active');
  currentSlide = slideIndex;
  
  // Update indicator
  document.getElementById('currentSlide').textContent = slideIndex + 1;
  document.getElementById('totalSlides').textContent = totalSlides;
  
  // Update tombol navigasi
  document.getElementById('prevBtn').disabled = (slideIndex === 0);
  document.getElementById('nextBtn').disabled = (slideIndex === totalSlides - 1);
}

// Close popup dengan ESC key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && document.getElementById('updatePopup').style.display === 'flex') {
    document.getElementById('updatePopup').style.display = 'none';
  }
});

// Close popup ketika klik di luar konten
document.getElementById('updatePopup').addEventListener('click', (e) => {
  if (e.target.id === 'updatePopup') {
    document.getElementById('updatePopup').style.display = 'none';
  }
});

// Tambahkan variabel di bagian atas script, setelah diamonds
let tickets = parseInt(localStorage.getItem("kastil_tickets")) || 0;
let unlockedUnits = JSON.parse(localStorage.getItem("kastil_unlocked_units")) || {
  god: false,
  neptun: false,
  circus: false,
  homesweet: false // <-- TAMBAHKAN INI
};

// Gacha rates
const gachaRates = [
  { type: 'god', emoji: 'ğŸª¬', chance: 0.01 },
  { type: 'neptun', emoji: 'ğŸ§œâ€â™‚ï¸', chance: 0.04 },
  { type: 'circus', emoji: 'ğŸª', chance: 0.05 },
  { type: 'ticket10', emoji: 'ğŸ«', amount: 10, chance: 0.10 },
  { type: 'ticket5', emoji: 'ğŸ«', amount: 5, chance: 0.20 },
  { type: 'ticket3', emoji: 'ğŸ«', amount: 3, chance: 0.30 },
  { type: 'ticket2', emoji: 'ğŸ«', amount: 2, chance: 0.30 }
];

// Event listeners untuk tombol gacha
document.getElementById("gachaBtn").onclick = () => {
  menu.style.display = "none";
  document.getElementById("gachaScreen").style.display = "block";
  updateGachaDisplay();
  updateUnitStatus();
};

document.getElementById("backFromGachaBtn").onclick = () => {
  document.getElementById("gachaScreen").style.display = "none";
  menu.style.display = "flex";
};

document.getElementById("spin1xBtn").onclick = () => spinGacha(1);
document.getElementById("spin5xBtn").onclick = () => spinGacha(5);

// Fungsi untuk update tampilan gacha
function updateGachaDisplay() {
  document.getElementById("ticketCount").innerText = tickets;
  document.getElementById("gachaDiamondCount").innerText = diamonds;
}

// Fungsi untuk spin gacha
function spinGacha(spinCount) {
  const cost = spinCount === 1 ? 50 : 250;
  
  if (diamonds < cost) {
    showNotification("ğŸ’ Diamond tidak cukup!");
    return;
  }
  
  diamonds -= cost;
  localStorage.setItem("diamonds", diamonds);
  document.getElementById("gemDisplay").innerText = "ğŸ’: " + diamonds;
  
  let results = [];
  let totalTickets = 0;
  
  for (let i = 0; i < spinCount; i++) {
    const result = spinSingleGacha();
    results.push(result);
    
    if (result.type.startsWith('ticket')) {
      totalTickets += result.amount;
    } else if (result.type === 'god' || result.type === 'neptun' || result.type === 'circus') {
      unlockUnit(result.type);
    }
  }
  
  // Tambahkan ticket jika dapat dari gacha
  if (totalTickets > 0) {
    tickets += totalTickets;
    localStorage.setItem("kastil_tickets", tickets);
  }
  
  // Tampilkan hasil
  displayGachaResults(results, spinCount);
  updateGachaDisplay();
  updateUnitStatus();
  
  // Update inventory jika sedang dibuka
  if (document.getElementById("inventoryScreen").style.display === "block") {
    renderInventory();
  }
}

// Fungsi untuk single spin
function spinSingleGacha() {
  const rand = Math.random();
  let cumulative = 0;
  
  for (const item of gachaRates) {
    cumulative += item.chance;
    if (rand <= cumulative) {
      return { ...item };
    }
  }
  
  // Fallback ke ticket 2
  return { type: 'ticket2', emoji: 'ğŸ«', amount: 2 };
}

// Fungsi untuk display hasil gacha
function displayGachaResults(results, spinCount) {
  let message = `ğŸ° Hasil Spin ${spinCount}x:\n`;
  results.forEach((result, index) => {
    if (result.type.startsWith('ticket')) {
      message += `${index + 1}. ${result.emoji} ${result.amount} Ticket\n`;
    } else {
      message += `${index + 1}. ${result.emoji} ${result.type.charAt(0).toUpperCase() + result.type.slice(1)}!\n`;
    }
  });
  
  // Tambahkan total ticket jika ada
  const totalTickets = results
    .filter(r => r.type.startsWith('ticket'))
    .reduce((sum, r) => sum + r.amount, 0);
    
  if (totalTickets > 0) {
    message += `\nTotal Ticket: +${totalTickets} ğŸ«`;
  }
  
  showNotification(message);
  
  // Special effect untuk unit rare
  const rareUnits = results.filter(r => ['god', 'neptun', 'circus'].includes(r.type));
  if (rareUnits.length > 0) {
    setTimeout(() => {
      showNotification(`ğŸ‰ SELAMAT! Anda mendapatkan unit ${rareUnits[0].emoji} ${rareUnits[0].type.toUpperCase()}!`);
    }, 1000);
  }
}

// Fungsi untuk unlock unit
function unlockUnit(unitType) {
  if (!unlockedUnits[unitType]) {
    unlockedUnits[unitType] = true;
    localStorage.setItem("kastil_unlocked_units", JSON.stringify(unlockedUnits));
    
    // Tambahkan ke equippedUnits jika belum ada
    if (!equippedUnits.includes(unitType)) {
      equippedUnits.push(unitType);
      if (equippedUnits.length > maxEquip) {
        equippedUnits.splice(0, equippedUnits.length - maxEquip);
      }
      localStorage.setItem("equippedUnits", JSON.stringify(equippedUnits));
    }
    
    showNotification(`ğŸ”“ Unit ${unitType} telah di-unlock!`);
  }
}

function redeemUnit(unitType) {
  const prices = {
    god: 100,
    neptun: 75,
    circus: 50,
    homesweet: 150 
  };
  
  const price = prices[unitType];
  
  if (unlockedUnits[unitType]) {
    showNotification(`Unit ${unitType} sudah di-unlock!`);
    return;
  }
  
  if (tickets < price) {
    showNotification(`ğŸ« Ticket tidak cukup! Dibutuhkan ${price} ticket.`);
    return;
  }
  
  tickets -= price;
  localStorage.setItem("kastil_tickets", tickets);
  
  unlockUnit(unitType);
  updateGachaDisplay();
  updateUnitStatus();
}

// Tambahkan di fungsi updateUnitStatus():
function updateUnitStatus() {
  document.getElementById("godStatus").innerHTML = 
    unlockedUnits.god ? '<span style="color:lime">âœ“ UNLOCKED</span>' : '<span style="color:red">LOCKED ğŸ”’</span>';
  document.getElementById("neptunStatus").innerHTML = 
    unlockedUnits.neptun ? '<span style="color:lime">âœ“ UNLOCKED</span>' : '<span style="color:red">LOCKED ğŸ”’</span>';
  document.getElementById("circusStatus").innerHTML = 
    unlockedUnits.circus ? '<span style="color:lime">âœ“ UNLOCKED</span>' : '<span style="color:red">LOCKED ğŸ”’</span>';
  document.getElementById("homesweetStatus").innerHTML = 
    unlockedUnits.homesweet ? '<span style="color:lime">âœ“ UNLOCKED</span>' : '<span style="color:red">LOCKED ğŸ”’</span>';
}

// MODIFIKASI: Update fungsi renderInventory() untuk handle unit yang locked
function renderInventory() {
  const allContainer = document.getElementById("allUnits");
  const eqContainer = document.getElementById("equippedUnits");
  allContainer.innerHTML = "";
  eqContainer.innerHTML = "";

  // gabung semua unit dari unitSets
  let allUnitsList = [];
  for (let cat in unitSets) {
    // Filter unit special yang masih locked
    if (cat === 'special') {
      unitSets[cat].forEach(u => {
        // Cek apakah unit special sudah di-unlock
        if (['god', 'neptun', 'circus', 'homesweet'].includes(u.type)) {
          if (!unlockedUnits[u.type]) {
            return; // Skip unit yang masih locked
          }
        }
        allUnitsList.push(u);
      });
    } else {
      allUnitsList = allUnitsList.concat(unitSets[cat]);
    }
  }

  allUnitsList.forEach(u => {
    const btn = document.createElement("button");
    btn.className = "unit-btn";
    
    // Tambahkan class god untuk unit god
    if (u.type === 'god') {
      btn.classList.add("god");
    }
    
    btn.innerText = `${u.emoji} ${u.type}`;
    if(equippedUnits.includes(u.type)) btn.classList.add("selected");

    btn.onclick = () => {
      if(equippedUnits.includes(u.type)){
        // unequip
        equippedUnits = equippedUnits.filter(x => x !== u.type);
      } else {
        // equip kalau masih <6
        if(equippedUnits.length < maxEquip){
          equippedUnits.push(u.type);
        } else {
          alert("Slot penuh! Maksimal 6 unit.");
        }
      }
      renderInventory();
    };

    allContainer.appendChild(btn);
  });

  // tampilkan equipped
  equippedUnits.forEach(t => {
    const span = document.createElement("div");
    span.style.margin = "5px";
    span.innerText = t;
    eqContainer.appendChild(span);
  });
}

// MODIFIKASI: Update fungsi showUnits() untuk filter unit yang locked
function showUnits(category){
  const container = document.getElementById('unitButtons');
  container.innerHTML = "";

  unitSets[category].forEach(u => {
    // âŒ Kalau mode normal tapi unit bukan dari inventory â†’ skip
    if (unitMode === "normal" && !equippedUnits.includes(u.type)) return;
    
    // âŒ Kalau unit special (god, neptun, circus) belum di-unlock â†’ skip
    // Update filter di showUnits():
if (category === 'special' && ['god', 'neptun', 'circus', 'homesweet'].includes(u.type)) {
  if (!unlockedUnits[u.type]) return;
    }

    const btn = document.createElement('button');
    btn.className = "unit-btn";
    
    // Tambahkan class god untuk unit god
    if (u.type === 'god') {
      btn.classList.add("god");
    }
    
    btn.innerText = `${u.emoji} ${u.cost}$`;

    btn.onclick = () => {
      selectUnitType(u.type);
      [...container.querySelectorAll("button")].forEach(b => b.classList.remove("selected"));
      btn.classList.add("selected");
    };

    container.appendChild(btn);
  });
}

// Panggil updateUnitStatus saat game dimulai
updateUnitStatus();

let endlessMode = false;
const maps = {
  map1: [
    {x:0,y:192},{x:192,y:192},{x:192,y:64},{x:384,y:64},
    {x:384,y:256},{x:576,y:256},{x:576,y:128},{x:768,y:128},
    {x:896,y:192},{x:1024,y:192}
  ],

  map2: [
    [ {x:0,y:100},{x:300,y:100},{x:300,y:300},{x:600,y:300},{x:1024,y:300} ],
    [ {x:0,y:400},{x:300,y:400},{x:300,y:200},{x:600,y:200},{x:1024,y:200} ]
  ],

  map3: [
    {x:0, y:500}, {x:300, y:500}, {x:300, y:400}, {x:100, y:400},
    {x:100, y:300}, {x:400, y:300}, {x:400, y:200}, {x:200, y:200},
    {x:200, y:100}, {x:600, y:100}, {x:600, y:300}, {x:800, y:300},
    {x:800, y:500}, {x:1024, y:500}
  ],

  map4: [
    [ {x:0,y:0}, {x:200,y:0}, {x:512,y:300} ],
    [ {x:0,y:600}, {x:200,y:600}, {x:512,y:300} ],
    [ {x:1024,y:0}, {x:824,y:0}, {x:512,y:300} ],
    [ {x:1024,y:600}, {x:824,y:600}, {x:512,y:300} ]
  ],

  map5: [
    {x:0,   y:50},  {x:900,y:50},  {x:900,y:550}, 
    {x:100,y:550}, {x:100,y:150}, {x:800,y:150}, 
    {x:800,y:450}, {x:200,y:450}, {x:200,y:250},
    {x:700,y:250}, {x:700,y:350}, {x:300,y:350},
    {x:300,y:300}, {x:500,y:300} 
  ], 

  map9: [
  {x:0, y:200},    // spawn (kuning kiri)
  {x:150, y:200},  
  {x:150, y:300},  
  {x:250, y:300},  
  {x:250, y:200},  
  {x:350, y:200},  // muter lingkaran kotak tengah
  {x:350, y:400},  
  {x:150, y:400},  
  {x:150, y:300},  
  {x:450, y:300},  
  {x:450, y:150},  
  {x:650, y:150},  
  {x:650, y:350},  
  {x:450, y:350},  
  {x:450, y:250},  
  {x:550, y:250},  
  {x:550, y:100},  
  {x:700, y:100},  
  {x:700, y:50}   // base (coklat atas)
],

  map6: [
  [ // Jalur ke Base Atas
    {x:0,   y:150}, 
    {x:200, y:100},  // naik
    {x:400, y:180},  // turun
    {x:600, y:120},  // naik lagi
    {x:800, y:160},  // turun lagi
    {x:1024,y:140}   // akhir
  ],
  [ // Jalur ke Base Bawah
    {x:0,   y:450}, 
    {x:200, y:500},  // turun
    {x:400, y:420},  // naik
    {x:600, y:470},  // turun lagi
    {x:800, y:430},  // naik
    {x:1024,y:450}   // akhir
   ]
  ], 

  map8: [
    [  // jalur normal
      {x: 0, y: 100},
      {x: 200, y: 100},
      {x: 400, y: 200},
      {x: 600, y: 250},
      {x: 800, y: 300},
      {x: 1024, y: 300}  // sampai base
    ],
     [
  {x: 800, y: 0},
  {x: 750, y:200}, 
  {x: 720, y: 350},
  {x: 700, y: 380},
  {x: 680, y: 410},
  {x: 700, y: 440},
  {x: 730, y: 460},
  {x: 770, y: 470},
  {x: 810, y: 460},
  {x: 850, y: 440},
  {x: 900, y: 410},
  {x: 950, y: 380},
  {x: 1024, y: 300}  // nyambung ke jalur utama sebelum base
    ]
  ], 
 
  map7: [
  [ // Cabang atas
    {x:0, y:300}, {x:250, y:300}, {x:500, y:300}, {x:650, y:200}, {x:800, y:150}, {x:1024, y:150}
  ],
  [ // Cabang tengah
    {x:0, y:300}, {x:250, y:300}, {x:500, y:300}, {x:650, y:300}, {x:800, y:300}, {x:1024, y:300}
  ],
  [ // Cabang bawah
    {x:0, y:300}, {x:250, y:300}, {x:500, y:300}, {x:650, y:400}, {x:800, y:450}, {x:1024, y:450}
  ]
]
};

const decorations = {
  map5: [
    {emoji:"ğŸŒ³",x:150,y:100}, {emoji:"ğŸŒ³",x:850,y:500},
    {emoji:"ğŸš·",x:400,y:80}, {emoji:"ğŸ›–",x:600,y:520},
    {emoji:"ğŸŒ²",x:250,y:400}, {emoji:"ğŸ³",x:750,y:200}
  ]
};
  let path = []; // path aktif nanti sesuai map

  const unitSets = {
  kastil: [
    { type: 'sword', emoji: 'ğŸ—¡', cost: 150 },
    { type: 'archer', emoji: 'ğŸ¹', cost: 200 },
    { type: 'speaker', emoji: 'ğŸ“»', cost: 300 },
    { type: 'priest', emoji: 'â›ª', cost: 400 }, 
    { type: 'capaw', emoji: 'ğŸªƒ', cost: 350 },
    { type: 'laser', emoji: 'ğŸ”¦', cost: 500 }, 
    { type: 'wrench', emoji: 'ğŸ”§', cost: 800 },
    { type: 'swordwrath', emoji: 'âš”ï¸', cost: 400 }, 
    { type: 'kompas', emoji: 'ğŸ§­', cost: 500 }
  ],
  manusia: [
  { type: 'scientist', emoji: 'ğŸ‘¨â€ğŸ”¬', cost: 550 },
  { type: 'chef', emoji: 'ğŸ‘¨â€ğŸ³', cost: 450 }, 
  { type: 'programmer', emoji: 'ğŸ‘¨â€ğŸ’»', cost: 750 }, 
  { type: 'farmer', emoji: 'ğŸ‘¨â€ğŸŒ¾', cost: 150 }, 
  { type: 'vampire', emoji: 'ğŸ§›â€â™‚ï¸', cost:700 }, 
  { type: 'ball', emoji: 'ğŸ¤¹â€â™‚ï¸', cost:300 }, 
  { type: 'police', emoji: 'ğŸ‘®', cost: 600 }, 
  { type: 'astronaut', emoji: 'ğŸ‘¨â€ğŸš€', cost: 800 },
  { type: 'insinyur', emoji: 'ğŸ‘·', cost: 300 }
],
unik: [
  { type: 'timemage', emoji: 'â³', cost: 900 },
  { type: 'falconer', emoji: 'ğŸ¦…', cost: 350 },
  { type: 'cupid', emoji: 'ğŸ’˜', cost: 200 },
  { type: 'judi', emoji: 'ğŸ°', cost: 555 },
  { type: 'plant', emoji: 'ğŸŒ±', cost: 150 },
  { type: 'bitcoin', emoji: 'ğŸª™', cost: 500 },
  { type: 'clock', emoji: 'â°', cost: 650 },
  { type: 'console', emoji: 'ğŸ®', cost: 500 },
  { type: 'dadu', emoji: 'ğŸ²', cost: 900 },
  { type: 'colors', emoji: 'ğŸ¨', cost: 300 }
],
military: [
  { type: 'lovers', emoji: 'ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', cost: 400 },
  { type: 'sniper', emoji: 'ğŸ¯', cost: 250 },
  { type: 'boost', emoji: 'ğŸ”‹', cost: 300 },
  { type: 'bombi', emoji: 'ğŸ’£', cost: 600 },
  { type: 'satellite', emoji: 'ğŸ›°', cost: 100 },
  { type: 'koboi', emoji: 'ğŸ¤ ', cost: 550 },
  { type: 'printer', emoji: 'ğŸ–¨', cost: 300 },
  { type: 'hook', emoji: 'ğŸª', cost: 750 }, 
  { type: 'cinema', emoji: 'ğŸ¬', cost: 600 }, 
  { type: 'star', emoji: 'â­', cost: 400 }
], 
  special: [
    { type: 'god', emoji: 'ğŸª¬', cost: 3000 },
    { type: 'neptun', emoji: 'ğŸ§œâ€â™‚ï¸', cost: 1250 }, 
    { type: 'circus', emoji: 'ğŸª', cost: 5000 },
    { type: 'homesweet', emoji: 'ğŸ©', cost: 1000 },
    { type: 'camera', emoji: 'ğŸ“·', cost: 1500 } 
  ]
};

function showUnits(category){
  const container = document.getElementById('unitButtons');
  container.innerHTML = "";

  unitSets[category].forEach(u => {
    // âŒ Kalau mode normal tapi unit bukan dari inventory â†’ skip
    if (unitMode === "normal" && !equippedUnits.includes(u.type)) return;

    const btn = document.createElement('button');
    btn.className = "unit-btn";
    btn.innerText = `${u.emoji} ${u.cost}$`;

    btn.onclick = () => {
      selectUnitType(u.type);
      [...container.querySelectorAll("button")].forEach(b => b.classList.remove("selected"));
      btn.classList.add("selected");
    };

    container.appendChild(btn);
  });
}
  const menu = document.getElementById("menu");
const gameArea = document.getElementById("gameArea");
const startBtn = document.getElementById("startBtn");
const retryScreen = document.getElementById("retryScreen"); // ğŸ”¥ tambahin ini
document.getElementById('sellBtn').onclick = () => {
  if(selectedUnit){
    
    // ğŸ”¥ CEK APAKAH UNIT ADALAH INSINYUR DAN TIDAK BISA DIJUAL
    if (selectedUnit.type === 'insinyur') {
      alert("ğŸ‘· Insinyur tidak bisa dijual!");
      return; // BATALKAN PENJUALAN
    }
    
    const sellPriceMap = { 
      sword:150, archer:200, speaker:300, chef:450, 
      sniper:250, lovers:400, scientist:550, timemage:900, 
      falconer:350, programmer:750, farmer:150, cupid:200, 
      boost:300, bombi:600, judi:555, priest:400, vampire:700, 
      ball:300, god:3000, neptun:1250, koboi:550, capaw:350, 
      printer:300, laser:500, satellite:100, police:600, 
      wrench:800, plant:150, turret:50, dadu:900, hook:750, circus:5000, clock:650, console:500, astronaut:800, homesweet:1000, camera:1500, swordwrath:400, kompas:500, colors:300, cinema:600, star:400, insinyur:300, 
      bitcoin: selectedUnit.type === 'bitcoin' ? selectedUnit.sellValue : 250 // khusus bitcoin
    };
    
    let sellPrice;
    
    // Hitung harga jual khusus untuk Bitcoin
    if (selectedUnit.type === 'bitcoin') {
      sellPrice = selectedUnit.sellValue;
      showNotification(`ğŸª™ Bitcoin terjual seharga ${sellPrice}!`);
    } else {
      sellPrice = Math.floor(sellPriceMap[selectedUnit.type] / 2);
    }
    
    money += sellPrice;

    if (selectedUnit.type === 'falconer' && selectedUnit.falcon) {
      const idx = summons.indexOf(selectedUnit.falcon);
      if (idx !== -1) summons.splice(idx, 1);
    }

    towers.splice(towers.indexOf(selectedUnit), 1);
    selectedUnit = null;
    document.getElementById('unitInfo').innerText = 'Klik unit untuk info';
    document.getElementById('upgradeCost').innerText = 'Harga Upgrade: -';
    
    // Reset tombol upgrade ke tampil normal
    document.getElementById('upgradeBtn').classList.remove('hidden');
  }
};

    startBtn.addEventListener("click", () => {
  endlessMode = false; // mode normal
  menu.style.display = "none";
  document.getElementById("mapSelect").style.display = "block"; 
});

    const endlessBtn = document.getElementById("endlessBtn");
endlessBtn.addEventListener("click", () => {
  endlessMode = true;
  menu.style.display = "none";
  document.getElementById("mapSelect").style.display = "block";
});
   
    const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let baseHP = 500, wave = 1, money = 300;
  let selectedType = 'sword';
  let selectedUnit = null;
  let spawning = false; // flag kontrol wave;
  let diamonds = parseInt(localStorage.getItem("diamonds")) || 0; 
 document.getElementById("gemDisplay").innerText = "ğŸ’: " + diamonds;

function addDiamonds(amount) {
  diamonds += amount;
  localStorage.setItem("diamonds", diamonds); // simpan ke browser
  document.getElementById("gemDisplay").innerText = "ğŸ’: " + diamonds;
}

let nightMode = false;        // apakah night mode aktif sekarang
let nightWaveActive = false;  // flag untuk menandai wave yang night
const NIGHT_CHANCE = 0.05;    // 5% chance per wave

function enableNightMode() {
  nightMode = true;
  nightWaveActive = true;
  // tampilkan overlay (kurangi brightness)
  const overlay = document.getElementById("nightOverlay");
  if (overlay) {
    overlay.style.display = "block";
    overlay.style.opacity = "1";
  }
  showNotification("ğŸŒ™Night Mode!");
}

function disableNightMode() {
  nightMode = false;
  nightWaveActive = false;
  const overlay = document.getElementById("nightOverlay");
  if (overlay) {
    overlay.style.opacity = "0";
    // tunggu transition sebelum hide supaya smooth
    setTimeout(() => { overlay.style.display = "none"; }, 600);
  }
  showNotification("â˜€ï¸ Night Mode selesai");
}

    // Tambahkan di bagian atas script, setelah variabel diamonds
let achievements = JSON.parse(localStorage.getItem("kastil_achievements")) || {
  winEasy: false,        // You Win!!! (easy)
  winNormal: false,      // How can you win? (normal)
  rich: false,           // You Are RICH!!! (Hard)
  endless50: false,      // You can do it! (normal)
  endless100: false      // THATS INSANE! (nightmare)
};

// Achievement data
const achievementData = [
  {
    id: "winEasy",
    title: "You Win!!!",
    difficulty: "Easy",
    description: "Menang di mode normal menggunakan all unit",
    emoji: "ğŸ¥‡",
    condition: () => achievements.winEasy
  },
  {
    id: "winNormal",
    title: "How can you win?",
    difficulty: "Normal",
    description: "Menang di mode normal menggunakan unit normal (6 unit inventory)",
    emoji: "ğŸ¥ˆ",
    condition: () => achievements.winNormal
  },
  {
    id: "rich",
    title: "You Are RICH!!!",
    difficulty: "Hard",
    description: "Memiliki 1000 ğŸ’",
    emoji: "ğŸ’°",
    condition: () => achievements.rich
  },
  {
    id: "endless50",
    title: "You can do it!",
    difficulty: "Normal",
    description: "Mendapatkan high score 50 wave di endless mode",
    emoji: "ğŸ¯",
    condition: () => achievements.endless50
  },
  {
    id: "endless100",
    title: "THATS INSANE!",
    difficulty: "Nightmare",
    description: "Mendapatkan high score 100 wave di endless mode",
    emoji: "ğŸ”¥",
    condition: () => achievements.endless100
  }
];

// Fungsi untuk unlock achievement
function unlockAchievement(id) {
  if (!achievements[id]) {
    achievements[id] = true;
    localStorage.setItem("kastil_achievements", JSON.stringify(achievements));
    
    // Tampilkan notifikasi
    const achievement = achievementData.find(a => a.id === id);
    if (achievement) {
      showNotification(`ğŸ† Achievement Unlocked: ${achievement.title}!`);
    }
    
    // Update tampilan achievement jika sedang terbuka
    if (document.getElementById("achievementScreen").style.display === "block") {
      renderAchievements();
    }
    
    return true;
  }
  return false;
}

// Fungsi untuk render achievement screen
function renderAchievements() {
  const container = document.getElementById("achievementsList");
  container.innerHTML = "";
  
  achievementData.forEach(ach => {
    const isUnlocked = ach.condition();
    const div = document.createElement("div");
    div.style.cssText = `
      background: ${isUnlocked ? 'rgba(0, 200, 0, 0.2)' : 'rgba(100, 100, 100, 0.2)'};
      border: 2px solid ${isUnlocked ? '#4CAF50' : '#666'};
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      text-align: left;
      position: relative;
    `;
    
    div.innerHTML = `
      <div style="font-size: 24px; position: absolute; right: 15px; top: 15px;">
        ${isUnlocked ? 'âœ…' : 'ğŸ”’'}
      </div>
      <div style="font-size: 28px; margin-bottom: 5px;">${ach.emoji} ${ach.title}</div>
      <div style="color: ${isUnlocked ? '#4CAF50' : '#FF9800'}; font-weight: bold;">
        Kesulitan: ${ach.difficulty}
      </div>
      <div style="margin-top: 5px; color: #ccc;">${ach.description}</div>
    `;
    
    container.appendChild(div);
  });
}

// Fungsi untuk cek achievement secara berkala
function checkAchievements() {
  // Cek achievement rich (1000 ğŸ’)
  if (diamonds >= 1000 && !achievements.rich) {
    unlockAchievement("rich");
  }
  
  // Cek achievement endless50 (high score >= 50)
  if (highScore >= 50 && !achievements.endless50) {
    unlockAchievement("endless50");
  }
  
  // Cek achievement endless100 (high score >= 100)
  if (highScore >= 100 && !achievements.endless100) {
    unlockAchievement("endless100");
  }
}

// Event listeners untuk tombol achievement
document.getElementById("achievementBtn").onclick = () => {
  menu.style.display = "none";
  document.getElementById("achievementScreen").style.display = "block";
  renderAchievements();
};

document.getElementById("backFromAchievementBtn").onclick = () => {
  document.getElementById("achievementScreen").style.display = "none";
  menu.style.display = "flex";
};

// Fungsi untuk cek achievement saat menang
function checkWinAchievements() {
  if (!endlessMode) {
    // Mode normal
    if (unitMode === "all" && !achievements.winEasy) {
      unlockAchievement("winEasy");
    } else if (unitMode === "normal" && !achievements.winNormal) {
      unlockAchievement("winNormal");
    }
  }
}

// Panggil checkAchievements secara berkala (setiap 5 detik)
setInterval(checkAchievements, 5000);

// Cek achievement saat game dimulai
checkAchievements();

// Tambahkan di bagian event listeners:
document.getElementById('timeStopBtn').onclick = () => {
  const now = Date.now();
  
  // Cek cooldown
  if (now < clockSkillCooldown) {
    const remaining = Math.ceil((clockSkillCooldown - now) / 1000);
    showNotification(`Skill dalam cooldown: ${remaining}s`);
    return;
  }
  
  // Aktifkan Time Stop
  timeStopActive = true;
  timeStopEnd = now + 10000; // 10 detik
  clockSkillCooldown = now + 100000; // 100 detik cooldown
  
  // Update tombol
  const timeStopBtn = document.getElementById('timeStopBtn');
  timeStopBtn.innerText = `â° Active!`;
  timeStopBtn.disabled = true;
  timeStopBtn.style.background = '#00cc00';
  
  showNotification("â° Waktu berhenti selama 10 detik!");
  
  // Timer untuk reset tombol
  setTimeout(() => {
    timeStopActive = false;
    showNotification("â° Waktu kembali normal");
  }, 10000);
  
  // Update cooldown display setiap detik
  const cdInterval = setInterval(() => {
    const remaining = clockSkillCooldown - Date.now();
    if (remaining <= 0) {
      clearInterval(cdInterval);
      timeStopBtn.innerText = 'â° Time Stop';
      timeStopBtn.disabled = false;
      timeStopBtn.style.background = '#0066cc';
    } else {
      const seconds = Math.ceil(remaining / 1000);
      timeStopBtn.innerText = `â° CD: ${seconds}s`;
    }
  }, 1000);
};

    let floatingTexts = [];
const barriers = [];
const enemies = [], towers = [], bullets = [], summons = [], lifts = [];

function drawFloatingTexts(ctx) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    let ft = floatingTexts[i];
    ctx.font = '16px Arial';
    ctx.fillStyle = `rgba(0,255,0,${ft.alpha})`;
    ctx.fillText(ft.text, ft.x, ft.y);

    // efek naik dan hilang
    ft.y -= 0.3;
    ft.alpha -= 0.01;

    if (ft.alpha <= 0) floatingTexts.splice(i, 1);
  }
}

   function drawPath(){
  const pathsToDraw = Array.isArray(path[0]) ? path : [path];
  pathsToDraw.forEach(p => {
    ctx.beginPath();
    ctx.lineWidth = 48;
    ctx.strokeStyle = '#333';
    ctx.moveTo(p[0].x, p[0].y);
    p.forEach(pt => ctx.lineTo(pt.x, pt.y));
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 40;
    ctx.strokeStyle = '#804000';
    ctx.moveTo(p[0].x, p[0].y);
    p.forEach(pt => ctx.lineTo(pt.x, pt.y));
    ctx.stroke();
  });

  // ğŸ”¥ Tambahin dekorasi kalau ada
  if (decorations[selectedMap]) {
    decorations[selectedMap].forEach(d => {
      ctx.font = "28px serif";
      ctx.fillText(d.emoji, d.x, d.y);
    });
  }
}

   class Enemy {
  constructor(type){
    if (type === "static") {
      this.type = "static";
      this.maxHealth = 15000;
      this.speed = 0.8;
      this.emoji = "ğŸ¤º";
      this.health = this.maxHealth;
      this.hasSummonedLift = false;
      this.createdAt = Date.now();
      this.liftSpawnDelay = Math.random() * 6000 + 4000;
    } else if (type === "las") {
      this.type = "las";
      this.maxHealth = 6500;
      this.speed = 0.8;
      this.emoji = "ğŸ‘¨â€ğŸ­";
      this.health = this.maxHealth;
    } else if (type === "luckyblock") {
      this.type = "luckyblock";
      this.maxHealth = 1777;
      this.speed = 0.9;
      this.emoji = "ğŸ€";
      this.health = this.maxHealth;
      this.lastTransform = Date.now();
    } else if (type === "necro") {
      this.type = "necro";
      this.maxHealth = 6000;
      this.speed = 0.7;
      this.emoji = "â˜ ï¸";
      this.health = this.maxHealth;
      this.lastSummon = Date.now();
    } else if (type === "minion") {
      this.type = "minion";
      this.maxHealth = 3000;
      this.speed = 1.0;
      this.emoji = "ğŸ’€";
      this.health = this.maxHealth;
    } else if (type === "thief") {
      this.type = "thief";
      this.maxHealth = 800;
      this.speed = 1.3;
      this.emoji = "ğŸ•µï¸â€â™‚ï¸";
      this.health = this.maxHealth;
    } else if (type === "engineer") {
    this.type = "engineer";
    this.maxHealth = 1500;
    this.speed = 0.6;
    this.health = this.maxHealth;
    this.emoji = "ğŸ‘¨â€ğŸ”§";
    this.lastSummon = Date.now();
    this.spawnedBots = 0; 
    } else if (type === "bot") {
    this.type = "bot";
    this.maxHealth = 500;
    this.speed = 0.8;
    this.health = this.maxHealth;
    this.emoji = "ğŸ¤–";
    } else if (type === "guru") {
  this.type = "guru";
  this.maxHealth = 5000;
  this.speed = 1.0;
  this.emoji = "ğŸ‘¨â€ğŸ«";
  this.health = this.maxHealth;
    } else if (type === "nuklir") {
  this.type = "nuklir";
  this.maxHealth = 15000;
  this.speed = 0.5;
  this.emoji = "â˜£ï¸";
  this.health = this.maxHealth;
    } else if (type === "nerd") {
  this.type = "nerd";
  this.emoji = "ğŸ¤“";
  this.maxHealth = 3000;
  this.health = this.maxHealth;
  this.speed = 0.8; 
  this.slowImmune = false;
    } else if (type === "bully") {
  this.type = "bully";
  this.emoji = "ğŸ‘¿";
  this.maxHealth = 7500;
  this.health = this.maxHealth;
  this.speed = 2.0; 
  this.slowImmune = true; // kebal slow
    } else if (type === "art") {
  this.type = "art"
  this.emoji = "ğŸ‘¨â€ğŸ¨";
  this.health = Math.floor(Math.random() * (15000 - 1000 + 1)) + 1000; // random HP
  this.maxHealth = this.health
  this.speed = 0.75;
    } else if (type === "santa") {
  this.type = "santa";
  this.maxHealth = 8500;
  this.speed = 0.7;
  this.emoji = "ğŸ…";
  this.health = this.maxHealth;
  this.lastSummon = Date.now();
    } else if (type === "liar") {
      this.type = "liar";
      this.maxHealth = 4500;
      this.speed = 1.5;
      this.emoji = "ğŸ‡";
      this.health = this.maxHealth;
    } else if (type === "kuda") {
      this.type = "kuda";
      this.maxHealth = 6000;
      this.speed = 0.75;
      this.emoji = "ğŸ´";
      this.health = this.maxHealth;
      this.type = type;
    } else if (type === "snow") {
      this.type = "snow";
      this.maxHealth = 8000;
      this.speed = 0.6;
      this.emoji = "â›„";
      this.health = this.maxHealth;
    } else if (type === "alien") {
  this.type = "alien";
  this.maxHealth = 7000;
  this.speed = 0.85;
  this.emoji = "ğŸ‘½";
  this.health = this.maxHealth;
  this.lastStun = Date.now();
    } else if (type === "ufo") {
  this.type = "ufo";
  this.maxHealth = 12500;
  this.health = this.maxHealth;
  this.speed = 1.5;
  this.emoji = "ğŸ›¸";
  this.lastSummon = Date.now();
    } else if (type === "toilet") {
  this.type = "toilet";
  this.maxHealth = 10000;
  this.speed = 0.75;
  this.emoji = "ğŸš½";
  this.health = this.maxHealth;
  this.slowImmune = true; // kebal slow
  this.lastSummon = Date.now();
    } else if (type === "poop") {
  this.type = "poop";
  this.maxHealth = 1000;
  this.speed = 2.0; // 2 detik
  this.emoji = "ğŸ’©";
  this.health = this.maxHealth;
  this.spawnTime = Date.now(); // waktu spawn
  this.effectApplied = false; // flag efek sudah diaplikasikan
    } else if (type === "duke") {
  this.type = "duke";
  this.maxHealth = 10000;
  this.speed = 0.3;
  this.emoji = "ğŸ¦¹â€â™€ï¸";
  this.health = this.maxHealth;
  this.lastBlink = Date.now();
  this.blinkInterval = 1500;
  this.blinkDistance = 150;
  this.timeStopImmune = true; // ğŸ”¥ TAMBAHKAN INI - KEBA TIME STOP
} else if (type === "posaidon") {
  this.type = "posaidon";
  this.maxHealth = 13000;
  this.speed = 0.75;
  this.emoji = "ğŸ§â€â™‚ï¸";
  this.health = this.maxHealth;
  this.slowImmune = true; // Kebal efek slow
  this.lastMirrorSpawn = Date.now();
  this.mirrorSpawnDelay = Math.floor(Math.random() * 5000) + 5000; // 5-10 detik
    } else if (type === "dancing") {
  this.type = "dancing";
  this.maxHealth = 2000;
  this.speed = 0.5;
  this.emoji = "ğŸ•º";
  this.health = this.maxHealth;
  this.hasSpawnedGuards = false;
  this.lastSpawnCheck = Date.now();
  this.spawnDelay = 4000; // 4 detik
} else if (type === "guard") {
  this.type = "guard";
  this.maxHealth = 1000;
  this.speed = 0.5;
  this.emoji = "ğŸ•´";
  this.health = this.maxHealth;
    } else {
      this.maxHealth = type==='hearts'?1750 : type==='furry'?250 : type==='shield'?500 : type==='ninja'?150 : type==='speedrun'?4000 : type==='angry'?50 : type==='reog'?2500 : type==='healer'?5000 : type==='zombie'?100 : 80;
      this.speed = type==='hearts'?1.25 : type==='furry'?1.2 : type==='shield'?0.45 : type==='ninja'?1.5 : type==='speedrun'?0.8 : type==='angry'?1.0 : type==='reog'?0.4 : type==='healer'?0.5 : type==='zombie'?0.5 : 0.7;
      this.emoji = type==='hearts'?'â¤ï¸â€ğŸ”¥' : type==='furry'?'ğŸ§šâ€â™‚ï¸' : type==='shield'?'ğŸ›¡' : type==='ninja'?'ğŸ¥·' : type==='speedrun'?'ğŸƒâ€â™‚ï¸' : type==='angry'?'ğŸ¤¬' : type==='reog'?'ğŸ‘¹' : type==='healer'?'â¤' : type==='zombie'?'ğŸ§Ÿâ€â™‚ï¸' : 'ğŸ‘»';
      this.health = this.maxHealth;
    }

    this.stunnedUntil = 0;
    this.slowMultiplier = 1.0;
    this.stunEndTime = 0;

    // path
    if(Array.isArray(path[0])){
      this.path = path[Math.floor(Math.random() * path.length)];
    } else {
      this.path = path;
    }
    this.pos = {...this.path[0]};
    this.pathIndex = 0;
  }

   takeDamage(amount) {
    if (this.type === "las") {
      this.health -= amount * 0.5; // cuma kena setengah
    } else {
      this.health -= amount;
    }
    if (this.health <= 0) {
      enemies.splice(enemies.indexOf(this), 1);
      money += 50; // kasih reward uang
    }
  }
 
    takeDamage(damage) {
  this.health -= damage;

  // ğŸ”¥ Efek khusus poop mati
if (this.type === "poop") {
  // Reset efek CD sebelum mati
  towers.forEach(tower => {
    if (tower.originalCooldown) {
      tower.cooldown = tower.originalCooldown;
      delete tower.originalCooldown;
    }
  });
}

  if (this.health <= 0) {
    // ğŸ”¥ Efek khusus nuklir
    if (this.type === "nuklir") {
      for (let i = 0; i < 5; i++) {
        if (towers.length > 0) {
          const idx = Math.floor(Math.random() * towers.length);
          const lostTower = towers[idx];
          towers.splice(idx, 1);

          if (lostTower.type === "falconer" && lostTower.falcon) {
            const summonIdx = summons.indexOf(lostTower.falcon);
            if (summonIdx !== -1) summons.splice(summonIdx, 1);
          }
        }
      }
    }

    // â„ï¸ Efek snow pecah jadi 2
    if (this.type === "snow") {
      let newHP = this.maxHealth / 2;
      if (newHP >= 1000) {
        for (let i = 0; i < 2; i++) {
          const child = new Enemy("snow");
          child.maxHealth = newHP;
          child.health = newHP;
          child.speed = this.speed;
          child.pos = { ...this.pos };
          child.path = this.path;
          child.pathIndex = this.pathIndex;
          enemies.push(child);
        }
      }
    }

    // ğŸ—‘ musuh mati â†’ hapus
    enemies.splice(enemies.indexOf(this), 1);
    money += 50;
  }
}

  update(){
  // CEK STUN - HARUS PALING ATAS
  if (this.stunnedUntil && Date.now() < this.stunnedUntil) {
    // Musuh tidak bergerak, tidak menyerang, tidak melakukan apapun
    // TETAP update timer visual doang
    return; // â­ LANGSUNG KELUAR, TIDAK BERGEROAK
  }
  
  // ğŸ”¥ DUKE IGNORE TIME STOP, musuh lain berhenti
  if (this.type !== "duke" && timeStopActive && Date.now() < timeStopEnd) {
    return;
  }

  // ğŸ¨ Efek racun dari Colors
if (this.poisonEffect && Date.now() < this.poisonEffect.endTime) {
  const now = Date.now();
  if (now - this.poisonEffect.lastTick >= 1000) { // setiap 1 detik
    this.health -= this.poisonEffect.damage;
    this.poisonEffect.lastTick = now;
    
    // Floating text damage racun
    floatingTexts.push({
      x: this.pos.x,
      y: this.pos.y - 20,
      text: `-20ğŸŸ¢`,
      alpha: 1,
      time: now
    });
  }
} else {
  delete this.poisonEffect;
}

  const next = this.path[this.pathIndex + 1];
  if(!next){
    baseHP -= 50;
    if (this.type === "thief") {
      money = Math.max(0, money - 250);
    }
    enemies.splice(enemies.indexOf(this), 1);
    return;
  }

  let currentSpeed = this.speed;
  if (
    this.type !== 'hearts' &&
    this.type !== 'ufo' &&
    this.slowUntil &&
    Date.now() < this.slowUntil
  ){
    currentSpeed *= 0.5;
  }

  const dx = next.x - this.pos.x;
  const dy = next.y - this.pos.y;
  const dist = Math.hypot(dx, dy);

  if(dist < currentSpeed){
    this.pos = {...next};
    this.pathIndex++;
  } else {
    this.pos.x += dx / dist * currentSpeed;
    this.pos.y += dy / dist * currentSpeed;
  }

  if (this.type === "static") {
    const now = Date.now();
    if (!this.hasSummonedLift && (now - this.createdAt) >= this.liftSpawnDelay) {
      const lift = new Lift(this.pos.x, this.pos.y);
      lifts.push(lift);
      this.hasSummonedLift = true;
    }
  }

if (this.type === "nerd" && this.health <= 1000) {
  this.type = "bully";
  this.emoji = "ğŸ‘¿";
  this.maxHealth = 7500;
  this.health = this.maxHealth;
  this.speed = 2.0;
  this.slowImmune = true;
   }

  if (this.type === "liar" && this.health < 1000) {
    this.type = "kuda";
    this.emoji = "ğŸ´";
    this.maxHealth = 6000;
    this.health = this.maxHealth;
    this.speed = 0.75;
  }

    // â˜ ï¸ Necro summon
    if (this.type === "necro") {
      if (Date.now() - this.lastSummon >= 5000) {
        const minion = new Enemy("minion");
        minion.path = this.path;
        minion.pos = {...this.pos};
        minion.pathIndex = this.pathIndex;
        enemies.push(minion);
        this.lastSummon = Date.now();
      }
    }
  
    if (this.type === "guru") {
  if (this.health < 2000) {
    this.speed = 3.0;
  }
}

// ğŸ›¸ UFO logic
if (this.type === "ufo") {
  const now = Date.now();
  if (now - this.lastSummon >= 4000) { // tiap 4 detik
    const minion = new Enemy("alien");
    minion.path = this.path;
    minion.pos = { ...this.pos };
    minion.pathIndex = this.pathIndex;
    enemies.push(minion);
    this.lastSummon = now;
  }
}

// ğŸ‘½ Alien bisa stun 3 tower random setiap 5 detik
if (this.type === "alien") {
  const now = Date.now();
  if (now - this.lastStun >= 5000) {
    if (towers.length > 0) {
      const shuffled = [...towers].sort(() => 0.5 - Math.random());
      const targets = shuffled.slice(0, Math.min(5, towers.length));

      targets.forEach(t => {
        t.stunnedUntil = now + 5000; // stun 5 detik
      });
    }
    this.lastStun = now;
  }
} 

    // ğŸ… Santa spawn musuh random setiap 5 detik
if (this.type === "santa") {
  const now = Date.now();
  if (now - this.lastSummon >= 2500) { 
    const enemyTypes = [
      "hearts","furry","shield","ninja","speedrun",
      "angry","reog","healer","zombie","thief","necro","las",
      "engineer","guru","nerd","art","luckyblock","liar"
    ];
    const newType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    const minion = new Enemy(newType);
    minion.path = this.path;
    minion.pos = {...this.pos};
    minion.pathIndex = this.pathIndex;
    enemies.push(minion);
    this.lastSummon = now;
  }
}

    // ğŸ€ LuckyBlock transform
    if (this.type === "luckyblock") {
      if (Date.now() - this.lastTransform >= 3000) {
        const enemyTypes = [
          "hearts","furry","shield","ninja","speedrun",
          "angry","reog","healer","zombie","thief","las",
          "engineer","guru","art","liar"
        ];
        const newType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const transformed = new Enemy(newType);

        // copy properti musuh baru
        this.type = transformed.type;
        this.maxHealth = transformed.maxHealth;
        this.health = transformed.maxHealth;
        this.speed = transformed.speed;
        this.emoji = transformed.emoji;
        this.lastSummon = transformed.lastSummon || null;
        this.lastTransform = Date.now();
      }
    }

// ğŸ§â€â™‚ï¸ POSAIDON - Mirror Teleport Skill (Spawn 1 Mirror Pair)
if (this.type === "posaidon") {
  const now = Date.now();
  
  // Spawn sepasang mirror setiap 5-10 detik
  if (now - this.lastMirrorSpawn >= this.mirrorSpawnDelay) {
    
    // POSISI MIRROR 1 = Posisi Posaidon saat ini
    const entranceX = this.pos.x;
    const entranceY = this.pos.y;
    
    // POSISI MIRROR 2 = 4 segment ke depan
    let exitIndex = this.pathIndex + 4;
    if (exitIndex >= this.path.length) {
      exitIndex = this.path.length - 1;
    }
    const exitPoint = this.path[exitIndex];
    
    if (exitPoint) {
      // BUAT 1 MIRROR PAIR (otomatis membuat mirror 1 dan mirror 2)
      const mirrorPair = new MirrorPair(
        entranceX, entranceY,
        exitPoint.x, exitPoint.y
      );
      
      mirrors.push(mirrorPair);
      
      // Floating text notifikasi (hanya 1 kali)
      floatingTexts.push({
        x: this.pos.x,
        y: this.pos.y - 40,
        text: `ğŸª Mirror Pair Spawned!`,
        alpha: 1,
        time: now
      });
      
      // Reset timer
      this.lastMirrorSpawn = now;
      this.mirrorSpawnDelay = Math.floor(Math.random() * 5000) + 5000;
    }
  }
}

// ğŸ•º Dancing logic - spawn 2 guard
if (this.type === "dancing" && !this.hasSpawnedGuards) {
  const now = Date.now();
  if (now - this.lastSpawnCheck >= this.spawnDelay) {
    
    // ğŸ”¥ GUARD DEPAN: di titik path yang sama dengan dancing (sedikit geser ke depan)
    const guardDepan = new Enemy("guard");
    guardDepan.path = this.path;
    guardDepan.pathIndex = this.pathIndex;
    
    // Hitung arah gerak dancing untuk posisi depan
    const nextPoint = this.path[this.pathIndex + 1];
    if (nextPoint) {
      // Arah dari posisi dancing ke titik selanjutnya
      const dx = nextPoint.x - this.pos.x;
      const dy = nextPoint.y - this.pos.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist > 0) {
        // Tempatkan guard 20px di depan dancing
        guardDepan.pos = {
          x: this.pos.x + (dx / dist) * 20,
          y: this.pos.y + (dy / dist) * 20
        };
      } else {
        guardDepan.pos = { ...this.pos };
      }
    } else {
      guardDepan.pos = { ...this.pos };
    }
    enemies.push(guardDepan);
    
    // ğŸ”¥ GUARD BELAKANG: di belakang dancing (geser ke belakang dari posisi dancing)
    const guardBelakang = new Enemy("guard");
    guardBelakang.path = this.path;
    guardBelakang.pathIndex = this.pathIndex;
    
    // Gunakan titik sebelumnya untuk arah ke belakang
    const prevPoint = this.path[Math.max(0, this.pathIndex - 1)];
    if (prevPoint && this.pathIndex > 0) {
      // Arah dari titik sebelumnya ke posisi dancing (kebalikan dari arah maju)
      const dx = this.pos.x - prevPoint.x;
      const dy = this.pos.y - prevPoint.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist > 0) {
        // Tempatkan guard 20px di belakang dancing
        guardBelakang.pos = {
          x: this.pos.x - (dx / dist) * 20,
          y: this.pos.y - (dy / dist) * 20
        };
      } else {
        guardBelakang.pos = { ...this.pos };
      }
    } else {
      // Kalau di awal path, tempatkan sedikit di belakang
      guardBelakang.pos = {
        x: this.pos.x - 20,
        y: this.pos.y
      };
    }
    enemies.push(guardBelakang);
    
    this.hasSpawnedGuards = true;
    
    // âŒ FLOATING TEXT DIHAPUS - tidak ada notifikasi spawn
  }
}
 
 // ğŸš½ Toilet logic - VERSI BARU
if (this.type === "toilet") {
  const now = Date.now();
  
  // Spawn 1 poop setiap 1.5 detik
  if (now - this.lastSummon >= 3000) {
    // Summon poop
    const poop = new Enemy("poop");
    poop.pos = { ...this.pos };
    poop.path = this.path;
    poop.pathIndex = this.pathIndex;
    enemies.push(poop);
    
    // Update timer
    this.lastSummon = now;
    
    // Floating text
    floatingTexts.push({
      x: this.pos.x,
      y: this.pos.y - 20,
      text: "ğŸ’©",
      alpha: 1,
      time: now
    });
  }
}

// ğŸ’© Poop logic (TETAP SAMA)
if (this.type === "poop") {
  const now = Date.now();
  const aliveTime = now - this.spawnTime;
  
  // Efek hanya berlaku selama 10 detik
  if (aliveTime <= 10000 && !this.effectApplied) {
    // Cari tower dalam radius 200
    towers.forEach(tower => {
      const dist = Math.hypot(tower.x - this.pos.x, tower.y - this.pos.y);
      if (dist < 200) {
        // Apply efek +100% CD (cooldown menjadi 2x)
        if (!tower.originalCooldown) {
          tower.originalCooldown = tower.cooldown;
        }
        tower.cooldown = tower.originalCooldown * 2; // CD menjadi 2x lebih lama
      }
    });
    this.effectApplied = true;
    
    // Notifikasi efek
    floatingTexts.push({
      x: this.pos.x,
      y: this.pos.y - 30,
      text: "ğŸ’© CD Tower +100%!",
      alpha: 1,
      time: now
    });
  }
  
  // Setelah 10 detik, reset efek
  if (aliveTime > 10000 && this.effectApplied) {
    // Reset CD tower ke normal
    towers.forEach(tower => {
      if (tower.originalCooldown) {
        tower.cooldown = tower.originalCooldown;
        delete tower.originalCooldown; // Hapus properti sementara
      }
    });
    this.effectApplied = false;
  }
  
  // Poop hilang setelah 12 detik
  if (aliveTime > 12000) {
    const idx = enemies.indexOf(this);
    if (idx !== -1) enemies.splice(idx, 1);
    
    // Reset semua efek sebelum hilang
    towers.forEach(tower => {
      if (tower.originalCooldown) {
        tower.cooldown = tower.originalCooldown;
        delete tower.originalCooldown;
      }
    });
  }
}

// Efek dance untuk dancing dan guard
if (this.type === "dancing" || this.type === "guard") {
  // Efek visual dance - mengubah posisi y sedikit agar terlihat seperti melompat
  const now = Date.now();
  const dancePhase = (now % 500) / 500; // 0-1 setiap 0.5 detik
  
  // Simpan posisi asli untuk floating
  if (!this.danceOffset) {
    this.danceOffset = Math.sin(now / 200) * 5;
  } else {
    // Update posisi y untuk efek melompat
    this.danceOffset = Math.sin(now / 200) * 8;
  }
}

  // ğŸ¦¹â€â™€ï¸ Duke blink logic - KEBA TIME STOP
if (this.type === "duke") {
  const now = Date.now();
  
  // Blink logic (tetap jalan meski time stop)
  if (now - this.lastBlink >= this.blinkInterval) {
    const next = this.path[this.pathIndex + 1];
    if (next) {
      const dx = next.x - this.pos.x;
      const dy = next.y - this.pos.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist > 0) {
        const moveDist = Math.min(this.blinkDistance, dist);
        this.pos.x += (dx / dist) * moveDist;
        this.pos.y += (dy / dist) * moveDist;
        
        if (moveDist >= dist - 1) {
          this.pos = {...next};
          this.pathIndex++;
        }
      }
    }
    
    floatingTexts.push({
      x: this.pos.x,
      y: this.pos.y - 30,
      text: "âœ¨ BLINK!",
      alpha: 1,
      time: now
    });
    
    this.lastBlink = now;
  }
  
  // Normal movement (DUKE IGNORE TIME STOP)
  const nextPoint = this.path[this.pathIndex + 1];
  if(!nextPoint){
    baseHP -= 50;
    enemies.splice(enemies.indexOf(this), 1);
    return;
  }

  let currentSpeed = this.speed;
  if (this.slowUntil && Date.now() < this.slowUntil){
    currentSpeed *= 0.5;
  }

  const dx = nextPoint.x - this.pos.x;
  const dy = nextPoint.y - this.pos.y;
  const dist = Math.hypot(dx, dy);

  if(dist < currentSpeed){
    this.pos = {...nextPoint};
    this.pathIndex++;
  } else {
    this.pos.x += dx / dist * currentSpeed;
    this.pos.y += dy / dist * currentSpeed;
  }
  
  return; // Skip general enemy logic, karena sudah dihandle khusus
}

     // ğŸ‘¨â€ğŸ”§ Engineer summon 4 bot ğŸ¤–
if (this.type === "engineer") {
    const now = Date.now();
    if (this.spawnedBots < 4 && now - this.lastSummon >= 2500) { // 1 detik delay
        const bot = new Enemy("bot");
        bot.path = this.path;
        bot.pos = {...this.pos};
        bot.pathIndex = this.pathIndex;
        enemies.push(bot);

        this.spawnedBots++;
        this.lastSummon = now;
    }
 }
}

// Perbarui method draw() di class Enemy
draw(){
  // Gambar emoji musuh
  ctx.font = '24px serif';
  ctx.fillText(this.emoji, this.pos.x, this.pos.y);

// ğŸ¨ Gambar efek warna di atas musuh (DARI COLORS)
  if (this.colorEffect && Date.now() < this.colorEffect.endTime) {
    ctx.font = '20px serif';
    ctx.fillText(this.colorEffect.emoji, this.pos.x, this.pos.y - 45);
  } else {
    delete this.colorEffect;
  }
  
  // Efek dance untuk dancing dan guard
  if (this.type === "dancing" || this.type === "guard") {
    const now = Date.now();
    const danceX = Math.sin(now / 150) * 5; // gerak ke kiri-kanan
    const danceY = Math.abs(Math.sin(now / 200)) * 8; // lompat
    
    if (this.type === "dancing") {
      // Dancing punya efek glow
      ctx.shadowColor = '#FF69B4';
      ctx.shadowBlur = 10 + Math.sin(now / 100) * 5;
    }
    
    // Gambar emoji dengan offset dance
    ctx.font = '28px serif';
    ctx.fillText(this.emoji, this.pos.x + danceX, this.pos.y - danceY + 14);
    
    // Reset shadow
    ctx.shadowBlur = 0;
    
    // Tambahkan efek partikel kecil (seperti kilauan) hanya untuk dancing
    if (this.type === "dancing" && Math.random() < 0.1) {
      ctx.font = '16px serif';
      ctx.globalAlpha = 0.3;
      ctx.fillText('âœ¨', this.pos.x - 10 + Math.random() * 20, this.pos.y - 30 + Math.random() * 10);
      ctx.globalAlpha = 1.0;
    }
  } else {
    // Gambar normal untuk musuh lain
    ctx.font = '24px serif';
    ctx.fillText(this.emoji, this.pos.x, this.pos.y);
  }

  // ğŸ’© Efek visual area efek poop
if (this.type === "poop") {
  const now = Date.now();
  const aliveTime = now - this.spawnTime;
  
  if (aliveTime <= 10000) {
    // Gambar area effect (lingkaran radius 200)
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, 200, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)'; // warna coklat transparan
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Timer efek
    const remainingTime = Math.ceil((10000 - aliveTime) / 1000);
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(`CD+100% (${remainingTime}s)`, this.pos.x, this.pos.y - 40);
  }
}
  
  // Gambar health bar di atas musuh
  const healthBarWidth = 40;
  const healthBarHeight = 6;
  const healthPercentage = this.health / this.maxHealth;
  
  // Background health bar (hitam)
  ctx.fillStyle = '#000';
  ctx.fillRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth, healthBarHeight);
  
  // Warna health bar berdasarkan persentase kesehatan
  if (healthPercentage > 0.7) {
    ctx.fillStyle = '#4CAF50'; // hijau untuk HP tinggi
  } else if (healthPercentage > 0.3) {
    ctx.fillStyle = '#FF9800'; // oranye untuk HP sedang
  } else {
    ctx.fillStyle = '#F44336'; // merah untuk HP rendah
  }
  
  // Fill health bar
  ctx.fillRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth * healthPercentage, healthBarHeight);
  
  // Border health bar
  ctx.strokeStyle = '#FFF';
  ctx.lineWidth = 1;
  ctx.strokeRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth, healthBarHeight);
  
  // Teks HP di bawah health bar (lebih kecil dan rapi)
  ctx.font = '10px sans-serif';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  
  // Format angka: bulatkan ke bawah dan gunakan k untuk ribuan
  let healthText;
  if (this.health >= 1000) {
    healthText = `${Math.floor(this.health/100)/10}k/${Math.floor(this.maxHealth/100)/10}k`;
  } else {
    healthText = `${Math.floor(this.health)}/${Math.floor(this.maxHealth)}`;
  }
  
  ctx.fillText(healthText, this.pos.x, this.pos.y - 10);
}
}

  if (selectedUnit === this && this.type !== 'turret') {
  ctx.beginPath();
  ctx.arc(this.x, this.y, this.range, 0, 2 * Math.PI);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.stroke();
}

// ğŸ¬ Tampilkan timer stun untuk Cinema
if (this.stunnedUntil && Date.now() < this.stunnedUntil) {
  const remainingSeconds = Math.ceil((this.stunnedUntil - Date.now()) / 1000);
  ctx.font = '14px sans-serif';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.fillText(`â–¶ï¸ ${remainingSeconds}s`, this.pos.x, this.pos.y - 55);
  
  // Efek visual stun (lingkaran kuning)
  ctx.beginPath();
  ctx.arc(this.pos.x, this.pos.y, 30, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

class MirrorPair {
  constructor(entranceX, entranceY, exitX, exitY) {
    // Mirror 1 (entrance)
    this.mirror1 = {
      x: entranceX,
      y: entranceY,
      targetX: exitX,
      targetY: exitY,
      createdAt: Date.now(),
      lifetime: 20000 // 20 detik
    };
    
    // Mirror 2 (exit) - SEBAGAI TITIK KELUAR
    this.mirror2 = {
      x: exitX,
      y: exitY,
      createdAt: Date.now(),
      lifetime: 20000
    };
    
    this.createdAt = Date.now();
    this.lifetime = 20000;
    this.lastTeleport = new Map();
    this.teleportCooldown = 500;
  }

  update() {
    const now = Date.now();
    
    // Hapus kedua mirror setelah 20 detik
    if (now - this.createdAt >= this.lifetime) {
      const idx = mirrors.indexOf(this);
      if (idx !== -1) mirrors.splice(idx, 1);
      return;
    }

    // UPDATE MIRROR 1 (Entrance) - Yang aktif teleport
    enemies.forEach(enemy => {
      // Posaidon tidak kena teleport
      if (enemy.type === "posaidon") return;
      
      const dist = Math.hypot(enemy.pos.x - this.mirror1.x, enemy.pos.y - this.mirror1.y);
      const enemyId = enemy.uniqueId || (enemy.uniqueId = Math.random());
      
      if (dist < 20 && now - (this.lastTeleport.get(enemyId) || 0) >= this.teleportCooldown) {
        // âœ… PERBAIKAN: Teleport ke mirror 2
        enemy.pos.x = this.mirror2.x;
        enemy.pos.y = this.mirror2.y;
        
        // âœ… PERBAIKAN: Update pathIndex ke titik terdekat di mirror 2
        let closestDist = Infinity;
        let closestIndex = 0;
        
        // Cari titik path terdekat dari posisi mirror 2
        const currentPath = enemy.path;
        for (let i = 0; i < currentPath.length; i++) {
          const point = currentPath[i];
          const dist = Math.hypot(point.x - this.mirror2.x, point.y - this.mirror2.y);
          if (dist < closestDist) {
            closestDist = dist;
            closestIndex = i;
          }
        }
        
        // Update pathIndex ke titik terdekat
        enemy.pathIndex = closestIndex;
        
        // Catat cooldown
        this.lastTeleport.set(enemyId, now);
        
        // Floating text teleport
        floatingTexts.push({
          x: enemy.pos.x,
          y: enemy.pos.y - 30,
          text: `âœ¨ TELEPORT!`,
          alpha: 1,
          time: now
        });
      }
    });
    
    // MIRROR 2 (Exit) - Hanya untuk visual
  }

  draw() {
    const now = Date.now();
    const remainingTime = Math.ceil((this.lifetime - (now - this.createdAt)) / 1000);
    
    // Mirror 1 (ENTRANCE) - Pink
    ctx.font = '28px serif';
    ctx.fillStyle = '#ff69b4';
    ctx.fillText('ğŸª', this.mirror1.x - 14, this.mirror1.y + 14);
    
    // Timer Mirror 1
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.shadowColor = '#ff69b4';
    ctx.shadowBlur = 4;
    ctx.textAlign = 'center';
    ctx.fillText(`â³ ${remainingTime}s`, this.mirror1.x, this.mirror1.y - 20);
    
    // Mirror 2 (EXIT) - Biru
    ctx.font = '28px serif';
    ctx.fillStyle = '#4169e1';
    ctx.fillText('ğŸª', this.mirror2.x - 14, this.mirror2.y + 14);
    
    // Timer Mirror 2
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.shadowColor = '#4169e1';
    ctx.fillText(`â³ ${remainingTime}s`, this.mirror2.x, this.mirror2.y - 20);
    
    // Reset shadow
    ctx.shadowBlur = 0;
    
    // Gambar garis penghubung
    ctx.beginPath();
    ctx.moveTo(this.mirror1.x, this.mirror1.y);
    ctx.lineTo(this.mirror2.x, this.mirror2.y);
    ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

    class Lift {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.createdAt = Date.now();
    this.lifeDuration = 30000;
    this.lastSpawn = 0;
    this.spawnInterval = 5000;
    this.emoji = "ğŸ›—";
    this.spawnedCount = 0;
  }
  
  update() {
    const now = Date.now();
    const aliveTime = now - this.createdAt;
    
    if (aliveTime >= this.lifeDuration) {
      const idx = lifts.indexOf(this);
      if (idx !== -1) lifts.splice(idx, 1);
      return;
    }
    
    if (now - this.lastSpawn >= this.spawnInterval) {
      this.spawnEnemy();
      this.lastSpawn = now;
      this.spawnedCount++;
    }
  }
  
  spawnEnemy() {
    const liftEnemies = ['santa', 'nerd', 'guru', 'alien', 'snow', 'liar', 'engineer', 'speedrun', 'las'];
    const type = liftEnemies[Math.floor(Math.random() * liftEnemies.length)];
    const enemy = new Enemy(type);
    
    enemy.pos = { x: this.x, y: this.y };
    
    if (Array.isArray(path[0])) {
      enemy.path = path[Math.floor(Math.random() * path.length)];
    } else {
      enemy.path = path;
    }
    
    let closestDist = Infinity;
    let closestIndex = 0;
    
    for (let i = 0; i < enemy.path.length - 1; i++) {
      const p1 = enemy.path[i];
      const p2 = enemy.path[i + 1];
      
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const len2 = dx * dx + dy * dy;
      
      if (len2 === 0) continue;
      
      let t = ((this.x - p1.x) * dx + (this.y - p1.y) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      
      const projX = p1.x + t * dx;
      const projY = p1.y + t * dy;
      
      const dist = Math.hypot(projX - this.x, projY - this.y);
      
      if (dist < closestDist) {
        closestDist = dist;
        closestIndex = i;
        if (t > 0.5) {
          closestIndex = i + 1;
        }
      }
    }
    
    enemy.pathIndex = Math.min(closestIndex, enemy.path.length - 1);
    
    enemies.push(enemy);
    
    floatingTexts.push({
      x: this.x,
      y: this.y - 20,
      text: `+${type}`,
      alpha: 1,
      time: Date.now()
    });
  }
  
  draw() {
    ctx.font = '28px serif';
    ctx.fillText(this.emoji, this.x - 14, this.y + 14);
    
    const remainingTime = Math.ceil((this.lifeDuration - (Date.now() - this.createdAt)) / 1000);
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'white';
    ctx.fillText(`${remainingTime}s`, this.x - 10, this.y - 10);
    ctx.fillText(`Spawn: ${this.spawnedCount}`, this.x - 15, this.y - 25);
  }
}

    class Tower {
  constructor(x, y, type){
    this.x = x; this.y = y;
    this.type = type;
    this.level = 1;
    this.lastShot = 0;
    this.lastSpawn = 0;
    this.lastLaser = 0;
    this.lastLoveSpawn = 0;
    this.lastSummon = 0;
    
    // âœ… INISIALISASI CAMERA DI SINI
    if (this.type === 'camera') {
      this.copiedFrom = null;
      this.lastCopyTime = 0;
      this.copyCooldown = 10000;
      this.originalType = 'camera';
    }
    
    // ğŸ”¥ Tambah properti untuk Bitcoin
    if (this.type === 'bitcoin') {
      this.createdAt = Date.now();
      this.sellValue = 250;
      this.lastValueIncrease = Date.now();
    }
    
    this.setStats();
  }

  setStats(){
  const stats = {
    sword:     { emoji: 'ğŸ—¡', baseDmg: 40, baseCD: 2000, baseRange: 100 },
    archer:    { emoji: 'ğŸ¹', baseDmg: 30, baseCD: 3000, baseRange: 200 },
    speaker:   { emoji: 'ğŸ“»', baseDmg: 10, baseCD: 1500, baseRange: 100 },
    chef:      { emoji: 'ğŸ‘¨â€ğŸ³', baseDmg: 25, baseCD: 3000, baseRange: 90 },
    sniper:    { emoji: 'ğŸ¯', baseDmg: 60, baseCD: 5000, baseRange: 120 },
    lovers:    { emoji: 'ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', baseDmg: 0, baseCD: 10000, baseRange: 200 },
    vampire:   { emoji: 'ğŸ§›â€â™‚ï¸', baseDmg: 0, baseCD: 12000, baseRange: 200 }, 
    scientist: { emoji: 'ğŸ‘¨â€ğŸ”¬', baseDmg: 0, baseCD: 8000, baseRange: 150 },
    timemage:  { emoji: 'â³', baseDmg: 0, baseCD: 5000, baseRange: 120 },
    falconer:  { emoji: 'ğŸ¦…', baseDmg: 10, baseCD: 0, baseRange: 200 },
    programmer:{ emoji: 'ğŸ‘¨â€ğŸ’»', baseDmg: 5, baseCD: 2000, baseRange: 120 },
    farmer:    { emoji: 'ğŸ‘¨â€ğŸŒ¾', baseDmg: 0, baseCD: 0, baseRange: 10 },
    cupid:     { emoji: 'ğŸ’˜', baseDmg: 25, baseCD: 1500, baseRange: 150 }, 
    boost:     { emoji: 'ğŸ”‹', baseDmg: 0, baseCD: 0, baseRange: 130 },
    bombi:     { emoji: 'ğŸ’£', baseDmg: 100, baseCD: 5000, baseRange: 100 }, 
    judi:      { emoji: 'ğŸ°', baseDmg: 0, baseCD: 4000, baseRange: 150 }, 
    priest:    { emoji: 'â›ª', baseDmg: 50, baseCD: 5000, baseRange: 200 }, 
    ball: { emoji: 'ğŸ¤¹â€â™‚ï¸', baseDmg: 15, baseCD: 3000, baseRange: 120 },
    god: { emoji: 'ğŸª¬', baseDmg: 99, baseCD: 20000, baseRange: 200 }, 
    neptun: { emoji: 'ğŸ§œâ€â™‚ï¸', baseDmg: 60, baseCD: 5000, baseRange: 150 }, 
    koboi: { emoji: 'ğŸ¤ ', baseDmg: 20, baseCD: 2000, baseRange: 150, range2: 80 }, 
    capaw: { emoji: 'ğŸªƒ', baseDmg: 20, baseCD: 3500, baseRange: 180 }, 
    printer: { emoji: 'ğŸ–¨', baseDmg: 0, baseCD: 10000, baseRange: 10 }, 
    laser: { emoji: 'ğŸ”¦', baseDmg: 5, baseCD: 200, baseRange: 150 }, 
    satellite: { emoji: 'ğŸ›°', baseDmg: 10, baseCD: 1000, baseRange: 100 }, 
    police: { emoji: 'ğŸ‘®', baseDmg: 50, baseCD: 2500, baseRange: 200 }, 
    wrench:   { emoji: 'ğŸ”§', baseDmg: 0, baseCD: 5000, baseRange: 200 },
    turret:   { emoji: 'ğŸ“¬', baseDmg: 50, baseCD: 1000, baseRange: 100 }, 
    plant:   { emoji: 'ğŸŒ±', baseDmg: 15, baseCD: 1000, baseRange: 120 },
    dadu:     { emoji: 'ğŸ²', baseDmg: 50, baseCD: 8000, baseRange: 150 }, 
    bitcoin: { emoji: 'ğŸª™', baseDmg: 0, baseCD: 0, baseRange: 100 }, 
    hook: { emoji: 'ğŸª', baseDmg: 50, baseCD: 2500, baseRange: 100 }, 
    circus:    { emoji: 'ğŸª', baseDmg: 0, baseCD: 12000, baseRange: 150 }, 
    clock:     { emoji: 'â°', baseDmg: 25, baseCD: 2000, baseRange: 120 }, 
    console:    { emoji: 'ğŸ®', baseDmg: 25, baseCD: 0, baseRange: 200 }, 
    astronaut: { emoji: 'ğŸ‘¨â€ğŸš€', baseDmg: 0, baseCD: 4000, baseRange: 200 }, 
    homesweet: { emoji: 'ğŸ©', baseDmg: 40, baseCD: 3000, baseRange: 150 }, 
    camera:     { emoji: 'ğŸ“·', baseDmg: 0, baseCD: 0, baseRange: 150 }, 
    swordwrath:  { emoji: 'âš”ï¸', baseDmg: 50, baseCD: 3000, baseRange: 120 }, 
    kompas:  { emoji: 'ğŸ§­', baseDmg: 30, baseCD: 3000, baseRange: 200 }, 
    colors: { emoji: 'ğŸ¨', baseDmg: 50, baseCD: 4000, baseRange: 150 }, 
    cinema: { emoji: 'ğŸ¬', baseDmg: 40, baseCD: 2500, baseRange: 160 }, 
    star: { emoji: 'â­', baseDmg: 20, baseCD: 2000, baseRange: 150 }, 
    insinyur: { emoji: 'ğŸ‘·', baseDmg: 20, baseCD: 15000, baseRange: 100 }
  }[this.type];

  if (!stats) return;

  this.emoji = stats.emoji;

  // default scaling
  if (this.type === "programmer") {
    this.damage = stats.baseDmg + (this.level - 1) * 5;
  } else {
    this.damage = stats.baseDmg + (this.level - 1) * 10;
  }
  this.cooldown = stats.baseCD * Math.pow(0.9, this.level - 1);
  this.range = stats.baseRange + (this.level - 1) * 10;

  if (this.type === "judi") {
  this.damage = Math.floor(Math.random() * (100 - 10 + 1)) + 10; 
  this.cooldown = 4000;
  this.range = 150;
}

  if (this.type === "satellite") {
  this.damage = 10 + (this.level - 1) * 10;   // tiap upgrade +10 dmg
  this.cooldown = 1000;                       // tetap 1 detik
  this.range = 100 + (this.level - 1) * 10;   // tiap upgrade +10 range
}

 // ğŸŸ¢ CODE BARU - Star dengan recharge 1500ms
if (this.type === 'star') {
  const starStats = [
    { dmg: 20, cd: 2000, range: 150, maxAmmo: 5 },  // Level 1
    { dmg: 40, cd: 2000, range: 175, maxAmmo: 5 },  // Level 2
    { dmg: 50, cd: 2000, range: 200, maxAmmo: 5 }   // Level 3
  ];
  const s = starStats[this.level - 1];
  this.emoji = 'â­';
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
  this.maxAmmo = s.maxAmmo;
  this.currentAmmo = s.maxAmmo;
  this.rechargeRate = 1500; // âœ… 1500ms (1.5 detik) per peluru
  this.lastRecharge = Date.now(); // Inisialisasi waktu recharge terakhir
}

  // âš¡ Cupid override
  if (this.type === "cupid") {
    const cupidStats = [
      { dmg: 25, cd: 1500, range: 150 },
      { dmg: 40, cd: 1500, range: 175 },
      { dmg: 50, cd: 1500, range: 190 },
      { dmg: 75, cd: 1500, range: 225 }
    ];
    const s = cupidStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

if (this.type === "colors") {
  const colorsStats = [
    { dmg: 50, cd: 4000, range: 150 },   // Level 1
    { dmg: 75, cd: 3500, range: 170 },   // Level 2
    { dmg: 100, cd: 3000, range: 200 },  // Level 3
    { dmg: 150, cd: 2500, range: 225 },  // Level 4
    { dmg: 175, cd: 2000, range: 240 }   // Level 5
  ];
  const s = colorsStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
}

  if (this.type === "police") {
  const policeStats = [
    { dmg: 50, cd: 2500, range: 200 },
    { dmg: 75, cd: 2500, range: 200 },
    { dmg: 90, cd: 2500, range: 200 },
    { dmg: 115, cd: 2000, range: 210 },
    { dmg: 125, cd: 2000, range: 225 }
  ];
  const s = policeStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
}

  if (this.type === "swordwrath") {
    const swordwrathStats = [
      { dmg: 50, cd: 3000, range: 120 },   // Level 1
      { dmg: 65, cd: 3000, range: 130 },   // Level 2
      { dmg: 80, cd: 3000, range: 140 },   // Level 3
      { dmg: 100, cd: 2500, range: 150 }   // Level 4
    ];
    const s = swordwrathStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

  if (this.type === "laser") {
    const laserStats = [
      { dmg: 5, cd: 200, range: 150 },
      { dmg: 15, cd: 200, range: 175 },
      { dmg: 25, cd: 250, range: 200 },
      { dmg: 30, cd: 300, range: 200 }, 
      { dmg: 50, cd: 400, range: 225 }
    ];
    const s = laserStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

  if (this.type === "cinema") {
  const cinemaStats = [
    { dmg: 40, cd: 2500, range: 160 },   // Level 1
    { dmg: 60, cd: 2500, range: 180 },   // Level 2
    { dmg: 90, cd: 2500, range: 200 },   // Level 3
    { dmg: 120, cd: 2500, range: 220 }   // Level 4
  ];
  const s = cinemaStats[this.level - 1];
  this.emoji = 'ğŸ¬';
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
  this.stunChance = 0.05; // 5% chance stun
  this.stunDuration = 5000; // 5 detik
}

  // âš¡ Bombi override
  if (this.type === "bombi") {
    const bombiStats = [
      { dmg: 100, cd: 5000, range: 100 },
      { dmg: 150, cd: 5000, range: 110 },
      { dmg: 200, cd: 4500, range: 120 },
      { dmg: 250, cd: 4500, range: 130 },
      { dmg: 300, cd: 6000, range: 150 }
    ];
    const s = bombiStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

   if (this.type === "chef") {
    const chefStats = [
      { dmg: 25, cd: 3000, range: 110 },
      { dmg: 50, cd: 3000, range: 140 },
      { dmg: 70, cd: 2500, range: 170 },
      { dmg: 90, cd: 2500, range: 200 }
    ];
    const s = chefStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

   if (this.type === "sniper") {
    const sniperStats = [
      { dmg: 60, cd: 5000, range: 120 },
      { dmg: 100, cd: 4500, range: 140 },
      { dmg: 150, cd: 4000, range: 170 },
      { dmg: 250, cd: 3500, range: 200 }
    ];
    const s = sniperStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

    if (this.type === "ball") {
    const ballStats = [
      { dmg: 15, cd: 4000, range: 110 },
      { dmg: 20, cd: 4000, range: 125 },
      { dmg: 35, cd: 3500, range: 140 },
      { dmg: 40, cd: 3500, range: 150 }, 
      { dmg: 50, cd: 3500, range: 165 }
    ];
    const s = ballStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

if (this.type === "hook") {
  const hookStats = [
    { dmg: 50, cd: 2500, range: 100 },
    { dmg: 70, cd: 2500, range: 120 },
    { dmg: 90, cd: 2500, range: 140 },
    { dmg: 125, cd: 2500, range: 160 },
    { dmg: 150, cd: 2500, range: 175 }
  ];
  const s = hookStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
}

if (this.type === 'kompas') {
  const kompasStats = [
    { dmg: 30, cd: 3000, range: 200 },   // Level 1
    { dmg: 50, cd: 3000, range: 200 },   // Level 2
    { dmg: 80, cd: 2500, range: 220 },   // Level 3
    { dmg: 100, cd: 2000, range: 240 }   // Level 4
  ];
  const s = kompasStats[this.level - 1];
  this.emoji = 'ğŸ§­';
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
}

if (this.type === 'insinyur') {
  const insinyurStats = [
    { cd: 15000 }, // Level 1 - CD 15 detik
    { cd: 15000 }, // Level 2
    { cd: 15000 }, // Level 3
    { cd: 15000 }, // Level 4
    { cd: 15000 }  // Level 5
  ];
  const s = insinyurStats[this.level - 1];
  this.emoji = 'ğŸ‘·';
  this.cooldown = s.cd;
  this.range = 100; // range untuk mencari tempat barrier
  this.lastSpawn = 0;
  this.hasBarrier = false; // flag apakah sudah punya barrier
  this.barrierDestroyed = false; // flag jika barrier hancur
  this.barrierDestroyedTime = 0;
}

if (this.type === "console") {
  const consoleStats = [
    { dmg: 25, cd: 0, range: 200 },
    { dmg: 40, cd: 0, range: 220 },
    { dmg: 60, cd: 0, range: 240 },
    { dmg: 75, cd: 0, range: 260 },
    { dmg: 100, cd: 0, range: 280 }
  ];
  
  // Cek index valid
  const index = Math.min(this.level - 1, consoleStats.length - 1);
  const s = consoleStats[index];
  
  this.emoji = 'ğŸ®'; // Set emoji
  this.damage = s.dmg;
  this.cooldown = s.cd; 
  this.range = s.range;
}

   if (this.type === "neptun") {
    const neptunStats = [
      { dmg: 60, cd: 5000, range: 150 },
      { dmg: 90, cd: 4000, range: 175 },
      { dmg: 120, cd: 3500, range: 190 },
      { dmg: 160, cd: 3000, range: 200 }, 
      { dmg: 200, cd: 3000, range: 225 }
    ];
    const s = neptunStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

  if (this.type === "capaw") {
    const capawStats = [
      { dmg: 20, cd: 3500, range: 200 },
      { dmg: 30, cd: 3000, range: 220 },
      { dmg: 45, cd: 3000, range: 240 },
      { dmg: 50, cd: 2500, range: 250 }, 
      { dmg: 65, cd: 2500, range: 260 }
    ];
    const s = capawStats[this.level - 1];
    this.damage = s.dmg;
    this.cooldown = s.cd;
    this.range = s.range;
  }

if (this.type === "homesweet") {
  const homesweetStats = [
    { dmg: 40, cd: 3000, range: 150, laserRange: 170, summonRange: 190 },   // Level 1
    { dmg: 65, cd: 3000, range: 170, laserRange: 180, summonRange: 210 },   // Level 2
    { dmg: 80, cd: 2500, range: 180, laserRange: 200, summonRange: 220 },   // Level 3
    { dmg: 120, cd: 2000, range: 190, laserRange: 210, summonRange: 230 }   // Level 4
  ];
  const s = homesweetStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;        // untuk peluru
  this.laserRange = s.laserRange;    // untuk laser
  this.summonRange = s.summonRange;  // untuk summon
  this.lastLoveSpawn = 0;
  this.lastLaser = 0;
}

 if (this.type === "plant") {
  const plantStats = [
    { emoji: "ğŸŒ±", dmg: 15, cd: 1000, range: 120 }, 
    { emoji: "ğŸŒ¿", dmg: 35, cd: 1500, range: 150 },
    { emoji: "ğŸª´", dmg: 40, cd: 2000, range: 160, aoe: true },
    { emoji: "ğŸŒ²", dmg: 70, cd: 3000, range: 200, aoe: true, aoeRange: 140 },
    { emoji: "ğŸ„", dmg: 100, cd: 4000, range: 200, aoe: true, aoeRange: 180, laserRange: 250, triple: true, laserCd: 500 }
  ];
  const s = plantStats[this.level - 1];
  this.emoji = s.emoji;
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
  this.aoe = s.aoe || false;
  this.aoeRange = s.aoeRange || 0;
  this.laserRange = s.laserRange || 0;
  this.triple = s.triple || false;
  this.laserCd = s.laserCd || 0;
  if (this.level === 5) this.lastLaser = 0; // timer laser sendiri
}

 // Tambahkan di dalam setStats():
if (this.type === "clock") {
  const clockStats = [
    { dmg: 25, cd: 2000, range: 120 }, // Level 1
    { dmg: 50, cd: 2000, range: 140 }, // Level 2
    { dmg: 75, cd: 2000, range: 160, aoe: true } // Level 3
  ];
  const s = clockStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;
  this.aoe = s.aoe || false;
}

 if (this.type === "koboi") {
  const koboiStats = [
    { dmg: 20, cd: 2500, range: 150, range2: 80 }, 
    { dmg: 40, cd: 2400, range: 160, range2: 90 }, 
    { dmg: 55, cd: 2300, range: 170, range2: 100 }, 
    { dmg: 70, cd: 2000, range: 180, range2: 120 }, 
    { dmg: 80, cd: 2000, range: 200, range2: 140 }
  ];
  const s = koboiStats[this.level - 1];
  this.damage = s.dmg;
  this.cooldown = s.cd;
  this.range = s.range;   // Range 1 (piercing)
  this.range2 = s.range2; // Range 2 (double shot)
  }
}

  upgrade() {
  if (this.type === "judi") {
    alert("ğŸ° Judi tidak bisa di-upgrade!");
    return;
  }

  if (this.type === "priest") {
  alert("â›ª Priest tidak bisa di-upgrade!");
  return;
}

  if (this.type === "god") {
  alert("ğŸª¬ God tidak bisa di-upgrade!") ;
  return;
 }

  if (this.type === "dadu") {
  alert("ğŸ² Dadu tidak bisa di-upgrade!") ;
  return;
 }

  if (this.type === "satellite") {
  const cost = this.level * 100; // harga upgrade selalu naik 100 per level
  if (money >= cost) {
    money -= cost;
    this.level++;
    this.setStats();

    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage} - Range ${this.range}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${ (this.level+1) * 100 }`;
    }
  }
  return;
}

  // ğŸŸ¢ CODE BARU - Info upgrade Star TANPA AMMO
if (this.type === "star") {
  const upgradeCosts = [0, 500, 750];
  if (this.level < 3 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    this.currentAmmo = this.maxAmmo; // Reset ammo setelah upgrade
    this.lastRecharge = Date.now(); // Reset timer recharge
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`; // âœ… AMMO DIHAPUS
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 3 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  if (this.type === "cupid") {
    const upgradeCosts = [0, 300, 450, 600]; // index = current level
    if (this.level < 4 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "plant") {
    const upgradeCosts = [0, 500, 1500, 2000, 3000]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

 // ğŸ¨ Colors upgrade
if (this.type === "colors") {
  const upgradeCosts = [0, 600, 1000, 1500, 2000]; // index = current level
  if (this.level < 5 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage} | CD ${this.cooldown/1000}s | Range ${this.range}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

if (this.type === "camera") {
  const upgradeCosts = [0, 800, 1500, 2500];
  if (this.level < 4 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    
    // Upgrade: kurangi cooldown copy dan naikkan range
    this.copyCooldown = 10000 - (this.level - 1) * 2000; // 10s, 8s, 6s, 4s
    this.range = 150 + (this.level - 1) * 25; // 150, 175, 200, 225
    
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ğŸ“· Camera | Copy CD: ${this.copyCooldown/1000}s`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

if (this.type === 'kompas') {
  const upgradeCosts = [0, 600, 1000, 1250]; // index = current level
  if (this.level < 4 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage} - CD ${this.cooldown/1000}s`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

if (this.type === "cinema") {
  const upgradeCosts = [0, 800, 1400, 2000]; // Level 1->2: 800, 2->3: 1400, 3->4: 2000
  if (this.level < 4 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage} - Range ${this.range}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

if (this.type === "swordwrath") {
    const upgradeCosts = [0, 500, 750, 1000]; // Level 1->2: 500, 2->3: 750, 3->4: 1000
    if (this.level < 4 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage} - CD ${this.cooldown/1000}s`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

if (this.type === "hook") {
  const upgradeCosts = [0, 800, 1500, 2500, 4000]; // index = current level
  if (this.level < 5 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  if (this.type === "bombi") {
    const upgradeCosts = [0, 500, 1000, 2000, 3000]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "police") {
    const upgradeCosts = [0, 750, 1000, 1600, 2500]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }
  
  if (this.type === "chef") {
    const upgradeCosts = [0, 200, 400, 800]; // index = current level
    if (this.level < 4 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

if (this.type === "homesweet") {
  const upgradeCosts = [0, 1200, 2500, 3000];
  if (this.level < 4 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} | Peluru:${this.range} | Laser:${this.laserRange} | Summon:${this.summonRange}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  if (this.type === "console") {
  const upgradeCosts = [0, 600, 750, 900, 1200];
  if (this.level < 5 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage} - Range ${this.range}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  if (this.type === 'insinyur') {
  const upgradeCosts = [0, 400, 600, 1000, 2000]; // Level 1->2: 400, 2->3: 600, 3->4: 1000, 4->5: 2000
  
  if (this.level < 5 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    
    // Update cooldown
    this.cooldown = 15000; // tetap 15 detik
    
    // Reset status barrier karena upgrade
    this.hasBarrier = false;
    this.barrierDestroyed = false;
    
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ğŸ‘· Insinyur | Barrier HP: ${getBarrierHP(this.level)}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
    }
    
    // Floating text upgrade
    floatingTexts.push({
      x: this.x,
      y: this.y - 20,
      text: `ğŸ”§ Upgrade ke level ${this.level}!`,
      alpha: 1,
      time: Date.now()
    });
  }
  return;
}

  if (this.type === "sniper") {
    const upgradeCosts = [0, 300, 900, 1500]; // index = current level
    if (this.level < 4 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 4 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "ball") {
    const upgradeCosts = [0, 250, 400, 700, 1200]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "neptun") {
    const upgradeCosts = [0, 800, 1650, 2500, 3200]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  
  if (this.type === "capaw") {
    const upgradeCosts = [0, 200, 500, 750, 1250]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "laser") {
    const upgradeCosts = [0, 600, 900, 1200, 1500]; // index = current level
    if (this.level < 5 && money >= upgradeCosts[this.level]) {
      money -= upgradeCosts[this.level];
      this.level++;
      this.setStats();
      if (selectedUnit === this) {
        document.getElementById('unitInfo').innerText =
          `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
        document.getElementById('upgradeCost').innerText =
          `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
      }
    }
    return;
  }

  if (this.type === "koboi") {
  const upgradeCosts = [0, 450, 900, 1750, 2600]; 
  if (this.level < 5 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  // Di dalam method upgrade(), tambahkan sebelum default upgrade:
if (this.type === "clock") {
  const upgradeCosts = [0, 900, 1750]; // level 1->2: 900, level 2->3: 1750
  if (this.level < 3 && money >= upgradeCosts[this.level]) {
    money -= upgradeCosts[this.level];
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 3 ? upgradeCosts[this.level] : 'Maks'}`;
    }
  }
  return;
}

  // default upgrade untuk tower biasa
  const cost = 100 * this.level;
  if (this.level < 5 && money >= cost) {
    money -= cost;
    this.level++;
    this.setStats();
    if (selectedUnit === this) {
      document.getElementById('unitInfo').innerText =
        `Level ${this.level} ${this.emoji} - Dmg ${this.damage}`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${this.level < 5 ? 100 * this.level : 'Maks'}`;
    }
  }
}

  update(){
  const now = Date.now();

  // Cek apakah tower lagi kena stun
if (this.stunnedUntil && Date.now() < this.stunnedUntil) {
  return; // skip attack
}

  if(this.type === 'vampire'){
    if(now - this.lastSpawn >= this.cooldown){
      summons.push(new VampireSummon(this.level));
      this.lastSpawn = now;
    }
    return; // vampire gak nembak, cuma summon
  }
    
  if (this.type === 'boost') {
    // boost cuma kasih aura, gak nembak
    return;
  }

  if (this.type === 'printer') {
  if (now - this.lastSpawn >= this.cooldown) {
    let incomeMap = {1:50, 2:100, 3:150, 4:200, 5:300};
    let gain = incomeMap[this.level] || 50;

    money += gain;
    this.lastSpawn = now;

    // bikin floating text income ğŸ’µ
    floatingTexts.push({
      x: this.x,
      y: this.y - 20,
      text: `+${gain}ğŸ’µ`,
      alpha: 1,
      time: Date.now()
    });
  }
  return; // printer ga nyerang
}

    // Di dalam method update() class Tower, tambahkan sebelum default logic:
if (this.type === 'clock') {
  if (now - this.lastShot >= this.cooldown) {
    const targets = enemies.filter(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (targets.length > 0) {
      // Level 1-2: single target
      if (this.level <= 2) {
        const target = targets[0];
        target.takeDamage(this.damage);
        bullets.push({ x: this.x, y: this.y, target: target, damage: this.damage });
      } 
      // Level 3: AoE damage
      else if (this.level === 3) {
        targets.forEach(e => {
          e.takeDamage(this.damage);
        });
        // Visual AoE
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(0, 200, 255, 0.3)";
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      this.lastShot = now;
    }
  }
  return; // Clock tidak menembak seperti tower biasa
}

    if (this.type === 'cinema') {
  if (now - this.lastShot >= this.cooldown) {
    // Cari target dalam range
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (target) {
      // Damage normal
      target.takeDamage(this.damage);
      
      // Peluru spesial ğŸ±
      bullets.push({ 
        x: this.x, 
        y: this.y, 
        target: target, 
        damage: this.damage,
        emoji: 'ğŸ±',
        from: this,
        type: 'cinema'
      });
      
      // 5% chance stun
      if (Math.random() < 0.05) { // this.stunChance
        // SET STUN LANGSUNG KE PROPERTI MUSUH
        target.stunnedUntil = now + 5000; // 5 detik
        
        // Simpan end time untuk timer visual
        target.stunEndTime = now + 5000;
        
        // Floating text stun dengan durasi
        floatingTexts.push({
          x: target.pos.x,
          y: target.pos.y - 45,
          text: `â–¶ï¸ 5s`,
          alpha: 1,
          time: now
        });
        
      }
      
      this.lastShot = now;
    }
  }
  return;
}

    if (this.type === "god") {
    if (now - this.lastSpawn >= this.cooldown) {
      const enemyTypes = [
        "hearts","furry","shield","ninja","speedrun","angry","reog",
        "healer","zombie","thief","engineer","guru","nerd","liar"
      ];
      const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      summons.push(new GodSummon(type)); // ğŸ”¥ summon musuh
      this.lastSpawn = now;
    }
    return;
  }

    if (this.type === 'dadu') {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    if (target) {
      const randomEffect = Math.floor(Math.random() * 5);
      
      switch(randomEffect) {
        case 0:
          target.takeDamage(this.damage);
          showNotification("?? Damage 50!");
          break;
        case 1:
          money += 200;
          showNotification("ğŸ² +200$!");
          break;
        case 2:
          target.slowUntil = Date.now() + 3000;
          target.slowMultiplier = 0.75;
          showNotification("ğŸ² Slow 25%!");
          break;
        case 3:
          if (target.pathIndex > 0) {
            target.pathIndex = Math.max(0, target.pathIndex - 3);
            const prevPoint = target.path[target.pathIndex];
            target.pos = { ...prevPoint };
            showNotification("ğŸ² Teleport back!");
          }
          break;
        case 4:
          const healAmount = Math.floor(target.maxHealth * 0.5);
          target.health = Math.min(target.maxHealth, target.health + healAmount);
          showNotification("ğŸ² Heal musuh +50% HP!");
          break;
      }
      
      this.lastShot = now;
    }
  }
  return;
}

    if (this.type === "koboi") {
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    // ğŸ”« Range 1: Piercing kayak Cupid
    const hits = enemies.filter(e => 
      e.pos.x > this.x && Math.abs(e.pos.y - this.y) < 20 && 
      e.pos.x - this.x <= this.range
    );

    hits.forEach(e => {
      e.takeDamage(this.damage);
      if (e.health <= 0) {
        const i = enemies.indexOf(e);
        if (i !== -1) enemies.splice(i, 1);
        money += 50;
      }
    });

    // ğŸ”« Range 2: Double shot fokus ke 1 target (delay 0.5 detik)
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range2
    );

    if (target) {
      for (let i = 0; i < 2; i++) {
        setTimeout(() => {
          if (enemies.includes(target)) {
            bullets.push({
              x: this.x,
              y: this.y,
              target: target,
              damage: this.damage
            });
          }
        }, i * 500); // 0.5 detik delay antar peluru
      }
    }

    // efek visual piercing line
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.range, this.y);
    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  return;
}

if (this.type === 'camera') {
  const now = Date.now();
  
  // Copy skill dari unit lain setiap 10 detik
  if (now - this.lastCopyTime >= this.copyCooldown) {
    this.copyRandomUnit();
    this.lastCopyTime = now;
  }
  
  // Jika sedang meniru unit lain, jalankan logika unit tersebut
  if (this.copiedFrom) {
    // Simulasikan behavior unit yang dicopy
    this.simulateCopiedUnit();
  }
  
  return;
}

if (this.type === "hook") {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (target) {
      // Damage utama
      target.takeDamage(this.damage);
      
      // Slow 20% selama 1 detik
      target.slowUntil = Date.now() + 1000;
      target.slowMultiplier = 0.8;
      
      // Kemungkinan 2.5% untuk teleport balik musuh
      if (Math.random() < 0.20) { // 20% chance
        if (target.pathIndex > 0) {
          target.pathIndex = Math.max(0, target.pathIndex - 3);
          const prevPoint = target.path[target.pathIndex];
          target.pos = { ...prevPoint };
          
          // Efek visual
          floatingTexts.push({
            x: target.pos.x,
            y: target.pos.y - 20,
            text: "ğŸŒ€ Teleport!",
            alpha: 1,
            time: Date.now()
          });
        }
      }
      
      // Peluru visual
      bullets.push({ 
        x: this.x, 
        y: this.y, 
        target: target, 
        damage: this.damage,
        from: this,
        type: "hook"
      });
      
      this.lastShot = now;
    }
  }
  return;
}

    // ğŸ¨ Colors - Efek warna merah, hijau, kuning
if (this.type === "colors") {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (target) {
      // Random warna: 0=merah, 1=hijau, 2=kuning
      const colorRoll = Math.floor(Math.random() * 3);
      let colorEmoji = "", effectText = "";
      
      // Set efek berdasarkan warna
      if (colorRoll === 0) { // MERAH - Slow 50%
        target.slowUntil = Date.now() + 5000; // 5 detik
        target.slowMultiplier = 0.5;
        colorEmoji = "ğŸ”´";
        
        // Ubah emoji musuh jadi versi merah (tambah ğŸ”´ di belakang)
        target.colorEffect = {
          type: "red",
          emoji: "ğŸ”´",
          endTime: Date.now() + 5000
        };
        
        // Efek racun (damage per detik)
        target.poisonEffect = {
          damage: 20,
          endTime: Date.now() + 5000,
          lastTick: now
        };
        
        target.colorEffect = {
          type: "green",
          emoji: "ğŸŸ¢",
          endTime: Date.now() + 5000
        };
        
        target.colorEffect = {
          type: "yellow",
          emoji: "ğŸŸ¡",
          endTime: Date.now() + 5000
        };
      }
      
      // Damage utama
      target.takeDamage(this.damage);
      
      // Efek visual peluru berwarna
      bullets.push({
        x: this.x,
        y: this.y,
        target: target,
        damage: this.damage,
        color: colorRoll === 0 ? "red" : (colorRoll === 1 ? "lime" : "gold"),
        emoji: "ğŸ¨"
      });
      
      // Floating text efek
      floatingTexts.push({
        x: target.pos.x,
        y: target.pos.y - 30,
        text: `${colorEmoji} ${effectText}`,
        alpha: 1,
        time: now
      });
      
      this.lastShot = now;
    }
  }
  return;
}

    if (this.type === 'astronaut') {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (target) {
      const rand = Math.random();
      let summonType;
      
      // Tentukan tipe summon berdasarkan persentase
      if (rand < 0.6) { // 60% - White Flag
        summonType = "white";
      } else if (rand < 0.99) { // 39% - Red Flag
        summonType = "red";
      } else { // 1% - Moon
        summonType = "moon";
      }
      
      // Summon unit sesuai type
      if (summonType === "white" || summonType === "red") {
        summons.push(new FlagSummon(this.x, this.y, summonType, target, this));
      } else if (summonType === "moon") {
        summons.push(new MoonSummon(this.x, this.y, target, this));
      }
      
      this.lastShot = now;
    }
  }
  return;
}

    if (this.type === 'insinyur') {
  const now = Date.now();
  
  // Inisialisasi properti jika belum ada
  if (this.lastSpawn === undefined) this.lastSpawn = 0;
  if (this.hasBarrier === undefined) this.hasBarrier = false;
  if (this.barrierDestroyed === undefined) this.barrierDestroyed = false;
  if (this.barrierDestroyedTime === undefined) this.barrierDestroyedTime = 0;
  
  // Cek apakah barrier sudah hancur dan sudah 15 detik
  if (this.barrierDestroyed && now - this.barrierDestroyedTime >= 15000) {
    this.hasBarrier = false;
    this.barrierDestroyed = false;
  }
  
  // Spawn barrier jika belum punya atau barrier hancur dan sudah cooldown
  if (!this.hasBarrier && now - this.lastSpawn >= this.cooldown) {
    // Cari posisi untuk barrier di sekitar insinyur
    const candidates = closestPointsOnPathWithinRange(this.x, this.y, 100);
    
    if (candidates.length > 0) {
      const c = candidates[Math.floor(Math.random() * candidates.length)];
      
      // Buat barrier baru
      const barrier = new EngineerBarrier(c.x, c.y, this.level, this);
      barriers.push(barrier);
      
      // Update status
      this.hasBarrier = true;
      this.barrierDestroyed = false;
      this.lastSpawn = now;
      
      // Floating text notifikasi
      floatingTexts.push({
        x: this.x,
        y: this.y - 20,
        text: `ğŸ—ï¸ Barrier level ${this.level}!`,
        alpha: 1,
        time: now
      });
    }
  }
  
  return; // Insinyur tidak menyerang
}

    if (this.type === "capaw") {
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    // Peluru boomerang maju
    bullets.push({
      x: this.x,
      y: this.y,
      from: this,
      type: "capaw",
      damage: this.damage,
      range: this.range,
      traveled: 0,
      returning: false
    });
  }
  return;
}

  if (this.type === "police") {
  if (now - this.lastSpawn >= this.cooldown) {
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    if (target) {
      // ğŸ”¥ HITUNG DAMAGE DENGAN CEK BOOST
      let finalDmg = this.damage;
      let hasBoost = false;
      let boostLevel = 0;
      
      const activeBoost = towers.find(t =>
        t.type === "boost" &&
        Math.hypot(t.x - this.x, t.y - this.y) < t.range
      );
      
      if (activeBoost) {
        const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
        finalDmg = Math.floor(finalDmg * bonusMap[activeBoost.level]);
        hasBoost = true;
        boostLevel = activeBoost.level;
      }
      
      // ğŸ”¥ EFEK VISUAL JIKA KENA BOOST (TANPA FLOATING TEXT)
      if (hasBoost) {
        // Visual aura di sekitar police
        ctx.beginPath();
        ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
        ctx.fillStyle = boostLevel >= 4 ? "rgba(0, 255, 0, 0.3)" : 
                       boostLevel >= 3 ? "rgba(0, 200, 255, 0.3)" : 
                       "rgba(255, 215, 0, 0.3)";
        ctx.fill();
        
      }
      
      // summon anjing dengan damage yang sudah di-boost
      const dog = new DogSummon(this.x, this.y, target, finalDmg);
      
      // ğŸ”¥ BERIKAN EFEK BOOST KE ANJING JUGA
      if (hasBoost) {
        dog.hasBoost = true;
        dog.boostLevel = boostLevel;
        
        // Anjing lebih besar jika kena boost
        dog.scale = 1.0 + (boostLevel * 0.1); // +10% per level
        dog.speed *= 1.0 + (boostLevel * 0.05); // +5% speed per level
        
        // Boost tinggi memberikan splash area yang lebih besar
        if (boostLevel >= 4) {
          dog.splashRange = 80; // normal 60
        } else if (boostLevel >= 3) {
          dog.splashRange = 70;
        }
      }
      
      summons.push(dog);
      this.lastSpawn = now;

      // ğŸ”Š efek suara anjing (lebih keras jika kena boost)
      let bark = new Audio("https://www.myinstants.com/media/sounds/dog-bark-sound-effect.mp3");
      if (hasBoost) {
        bark.volume = 0.8; // lebih keras
      }
      bark.play();
    }
  }
  return;
}

if (this.type === 'swordwrath') {
    if (now - this.lastShot >= this.cooldown) {
      this.lastShot = now;
      
      // Cari target dalam range
      const target = enemies.find(e => 
        Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
      );
      
      if (target) {
        // Spawn 2 peluru dengan jeda 0.5 detik
        for (let i = 0; i < 2; i++) {
          setTimeout(() => {
            if (enemies.includes(target)) { // cek musuh masih ada
              // Hitung damage dengan cek boost
              let dmg = this.damage;
              
              const activeBoost = towers.find(t =>
                t.type === "boost" &&
                Math.hypot(t.x - this.x, t.y - this.y) < t.range
              );
              
              if (activeBoost) {
                const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
                dmg = Math.floor(dmg * bonusMap[activeBoost.level]);
              }
              
              bullets.push({
                x: this.x,
                y: this.y,
                target: target,
                damage: dmg,
                emoji: 'âš”ï¸'
              });
            }
          }, i * 500); // 0.5 detik jeda antar tembakan
        }
      }
    }
    return;
  }

  // Tambahkan di method update() Tower class, sebelum cek stun:
if (this.type === 'bitcoin') {
  const now = Date.now();
  // Naik nilai jual setiap 5 detik
  if (now - this.lastValueIncrease >= 5000) {
    this.sellValue += 50;
    this.lastValueIncrease = now;
    
    // Tampilkan notifikasi setiap kenaikan nilai (opsional)
    if (Math.random() < 0.3) { // 30% chance tampilkan notifikasi
      floatingTexts.push({
        x: this.x,
        y: this.y - 20,
        text: `ğŸª™+50`,
        alpha: 1,
        time: Date.now()
      });
    }
  }
  return; // Bitcoin tidak menyerang
}

   if (this.type === 'circus') {
  if (now - this.lastSpawn >= this.cooldown) {
    // Random summon berdasarkan persentase
    const rand = Math.random();
    let summonType, summonHP;
    
    if (rand < 0.25) {
      summonType = "ğŸšµâ€â™€ï¸"; // sepeda
      summonHP = 250;
    } else if (rand < 0.5) {
      summonType = "ğŸ§—â€â™‚ï¸"; // manjat
      summonHP = 500;
    } else if (rand < 0.75) {
      summonType = "ğŸ„â€â™‚ï¸"; // driver
      summonHP = 1000;
    } else {
      summonType = "â›·ï¸"; // salju
      summonHP = 2500;
    }
    
    // Buat summon baru dengan sistem tabrak
    const circusSummon = new CircusSummon(this.x, this.y, summonType, summonHP);
    summons.push(circusSummon);
    
    // Tampilkan notifikasi
    floatingTexts.push({
      x: this.x,
      y: this.y - 20,
      text: `Summon ${summonType}`,
      alpha: 1,
      time: Date.now()
    });
    
    this.lastSpawn = now;
  }
  return;
}

// ğŸŸ¢ CODE BARU - Star dengan tracking waktu recharge
if (this.type === 'star') {
  const now = Date.now();
  
  // Inisialisasi lastRecharge jika belum ada
  if (this.lastRecharge === undefined) {
    this.lastRecharge = now;
  }
  
  // Recharge ammo secara periodik (1500ms)
  if (this.currentAmmo < this.maxAmmo && now - this.lastRecharge >= this.rechargeRate) {
    this.currentAmmo++;
    this.lastRecharge = now; // Reset timer untuk peluru berikutnya
  }
  
  // Menembak jika ada target dan punya ammo cukup (5)
  if (now - this.lastShot >= this.cooldown && this.currentAmmo >= 5) {
    // Cari target dalam range
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (target) {
      // Tembakkan 5 peluru ke 1 musuh
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          if (enemies.includes(target)) { // Cek musuh masih ada
            bullets.push({
              x: this.x,
              y: this.y,
              target: target,
              damage: this.damage,
              emoji: 'â˜€',
              from: this,
              type: 'star'
            });
          }
        }, i * 100);
      }
      
      // Kurangi ammo
      this.currentAmmo -= 5;
      this.lastShot = now;
      
      // Efek visual
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
  return;
}

if (this.type === "plant") {
  // ğŸ”¥ CEK BOOST SEKALI UNTUK SEMUA LEVEL
  let hasBoost = false;
  let boostLevel = 0;
  let boostMultiplier = 1.0;
  
  const activeBoost = towers.find(t =>
    t.type === "boost" &&
    Math.hypot(t.x - this.x, t.y - this.y) < t.range
  );
  
  if (activeBoost) {
    const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
    boostMultiplier = bonusMap[activeBoost.level];
    hasBoost = true;
    boostLevel = activeBoost.level;
  }
  
  // target utama
  const target = enemies.find(e => {
    const dx = e.pos.x - this.x;
    const dy = e.pos.y - this.y;
    return Math.hypot(dx, dy) <= (this.laserRange || this.range);
  });

  // === Level 5 ===
  if (this.level === 5) {
    // AoE + triple peluru (pakai cooldown utama)
    if (now - this.lastShot >= this.cooldown && target) {
      // Hitung final damage dengan boost
      const finalDamage = Math.floor(this.damage * boostMultiplier);
      
      // ğŸ”¥ EFEK VISUAL BOOST PADA PLANT
      if (hasBoost) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = boostLevel >= 4 ? "rgba(0, 255, 0, 0.4)" :
                       boostLevel >= 3 ? "rgba(0, 200, 255, 0.4)" :
                       "rgba(255, 215, 0, 0.4)";
        ctx.fill();
      }
      
      // AoE damage
      enemies.forEach(e => {
        const dx = e.pos.x - this.x;
        const dy = e.pos.y - this.y;
        if (Math.hypot(dx, dy) <= this.aoeRange) {
          e.takeDamage(finalDamage);
          
          // ğŸ”¥ FLOATING TEXT DAMAGE UNTUK AOE
          if (hasBoost) {
            floatingTexts.push({
              x: e.pos.x,
              y: e.pos.y - 20,
              text: `-${finalDamage}`,
              alpha: 1,
              time: Date.now()
            });
          }
        }
      });

      // Triple peluru fokus target
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          bullets.push({
            x: this.x, y: this.y,
            target: target,
            damage: finalDamage,
            emoji: this.emoji,
            color: hasBoost ? "#00FF00" : undefined // hijau jika boosted
          });
          
          // ğŸ”¥ FLOATING TEXT UNTUK TRIPLE SHOT
          if (hasBoost && i === 0) { // hanya sekali per salvo
            floatingTexts.push({
              x: this.x,
              y: this.y - 30,
              text: `ğŸŒ¿Ã—3`,
              alpha: 1,
              time: Date.now()
            });
          }
        }, i * 500);
      }

      this.lastShot = now;
    }

    // Laser terpisah (0.5 detik sekali) - JUGA DAPAT BOOST
    if (target && now - this.lastLaser >= this.laserCd) {
      const laserDamage = Math.floor(this.damage * boostMultiplier);
      
      ctx.beginPath();
      if (hasBoost) {
        ctx.strokeStyle = boostLevel >= 4 ? "#00FF00" : 
                         boostLevel >= 3 ? "#00BFFF" : "#FFFF00";
        ctx.lineWidth = 4;
        ctx.shadowColor = hasBoost ? "#00FF00" : "yellow";
        ctx.shadowBlur = 10;
      } else {
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 3;
      }
      
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(target.pos.x, target.pos.y);
      ctx.stroke();
      ctx.shadowBlur = 0;

      target.takeDamage(laserDamage);
      
      // ğŸ”¥ FLOATING TEXT LASER DAMAGE
      if (hasBoost) {
        floatingTexts.push({
          x: target.pos.x,
          y: target.pos.y - 20,
          text: `-${laserDamage}â˜€ï¸`,
          alpha: 1,
          time: Date.now()
        });
      }
      
      this.lastLaser = now;
    }

    return;
  }

  // === Level 1â€“4 ===
  if (now - this.lastShot >= this.cooldown) {
    if (!target) return;
    
    // Hitung final damage dengan boost
    const finalDamage = Math.floor(this.damage * boostMultiplier);
    
    // ğŸ”¥ EFEK VISUAL BOOST PADA PLANT
    if (hasBoost) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = boostLevel >= 4 ? "rgba(0, 255, 0, 0.3)" :
                     boostLevel >= 3 ? "rgba(0, 200, 255, 0.3)" :
                     "rgba(255, 215, 0, 0.3)";
      ctx.fill();
    }

    if (this.level <= 2) {
      // single peluru
      bullets.push({
        x: this.x, y: this.y,
        target: target,
        damage: finalDamage,
        emoji: this.emoji,
        color: hasBoost ? "#00FF00" : undefined
      });
      
      // ğŸ”¥ FLOATING TEXT UNTUK SINGLE SHOT
      if (hasBoost) {
        floatingTexts.push({
          x: target.pos.x,
          y: target.pos.y - 20,
          text: `-${finalDamage}`,
          alpha: 1,
          time: Date.now()
        });
      }
    } 
    else if (this.level === 3) {
      // AoE (mirip speaker)
      enemies.forEach(e => {
        const dx = e.pos.x - this.x;
        const dy = e.pos.y - this.y;
        if (Math.hypot(dx, dy) <= this.range) {
          e.takeDamage(finalDamage);
          
          // ğŸ”¥ FLOATING TEXT UNTUK AOE
          if (hasBoost) {
            floatingTexts.push({
              x: e.pos.x,
              y: e.pos.y - 20,
              text: `-${finalDamage}`,
              alpha: 1,
              time: Date.now()
            });
          }
        }
      });
    } 
    else if (this.level === 4) {
      // AoE + single
      enemies.forEach(e => {
        const dx = e.pos.x - this.x;
        const dy = e.pos.y - this.y;
        if (Math.hypot(dx, dy) <= this.aoeRange) {
          e.takeDamage(finalDamage);
          
          // ğŸ”¥ FLOATING TEXT UNTUK AOE
          if (hasBoost) {
            floatingTexts.push({
              x: e.pos.x,
              y: e.pos.y - 20,
              text: `-${finalDamage}`,
              alpha: 1,
              time: Date.now()
            });
          }
        }
      });
      
      // Single target damage
      target.takeDamage(finalDamage);
      
      // ğŸ”¥ FLOATING TEXT UNTUK SINGLE TARGET
      if (hasBoost) {
        floatingTexts.push({
          x: target.pos.x,
          y: target.pos.y - 20,
          text: `-${finalDamage}â­`,
          alpha: 1,
          time: Date.now()
        });
      }
    }

    this.lastShot = now;
  }
  return;
}

  if (this.type === 'kompas') {
  const now = Date.now();
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    // 4 arah: atas, kanan, bawah, kiri
    const directions = [
      { x: 0, y: -1 }, // atas
      { x: 1, y: 0 },  // kanan
      { x: 0, y: 1 },  // bawah
      { x: -1, y: 0 }  // kiri
    ];

    directions.forEach(dir => {
      bullets.push({
        x: this.x,
        y: this.y,
        vx: dir.x * 6,
        vy: dir.y * 6,
        damage: this.damage,
        from: this,
        type: 'kompas',
        maxTravel: this.range,
        traveled: 0,
        hitEnemies: new Set() // ğŸ”¥ PENTING: track musuh yang sudah kena
      });
    });

    // Efek visual
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  return;
}

    if (this.type === 'wrench') {
  if (now - this.lastSpawn >= this.cooldown) {
    // cari posisi musuh terdekat dalam jangkauan wrench
    const target = enemies.find(e =>
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );

    if (target) {
      const turret = new Tower(target.pos.x, target.pos.y, "turret");
      towers.push(turret);

      // auto hapus turret setelah 15 detik
      setTimeout(() => {
        const idx = towers.indexOf(turret);
        if (idx !== -1) towers.splice(idx, 1);
      }, 15000);
    }

    this.lastSpawn = now;
  }
  return;
}

if (this.type === 'turret') {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e =>
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    if (target) {
      bullets.push({ x: this.x, y: this.y, target: target, damage: this.damage });
      this.lastShot = now;
    }
  }
  return; // turret hanya nembak musuh
}

    if(this.type === 'scientist'){
  if(this.lastSpawn === undefined) this.lastSpawn = 0;  // inisialisasi sekali
  const barrierCD = 8000; 
  if(now - this.lastSpawn >= barrierCD){
    const candidates = closestPointsOnPathWithinRange(this.x, this.y, this.range);
    if(candidates.length > 0){
      const c = candidates[Math.floor(Math.random() * candidates.length)];
      barriers.push(new Barrier(c.x, c.y, 300 + (50 * (this.level - 1))));
    }
    this.lastSpawn = now;
  }
  return;
}

 if (this.type === 'bombi') {
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    // ğŸ”¥ HITUNG DAMAGE DENGAN CEK BOOST
    let finalDmg = this.damage;
    let hasBoost = false;
    let boostLevel = 0;
    
    const activeBoost = towers.find(t =>
      t.type === "boost" &&
      Math.hypot(t.x - this.x, t.y - this.y) < t.range
    );
    
    if (activeBoost) {
      const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
      finalDmg = Math.floor(finalDmg * bonusMap[activeBoost.level]);
      hasBoost = true;
      boostLevel = activeBoost.level;
    }

    // serang semua musuh dalam jangkauan (AoE bom)
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
      if (dist < this.range) {
        // ğŸ”¥ Damage dengan boost multiplier
        e.takeDamage(finalDmg);

        // ğŸ”¥ TAMPILKAN FLOATING TEXT DAMAGE HANYA JIKA KENA BOOST
        if (hasBoost) {
          floatingTexts.push({
            x: e.pos.x,
            y: e.pos.y - 30,
            text: `-${finalDmg}`,
            alpha: 1,
            time: Date.now()
          });
        }

        // cek kalau musuh mati
        if (e.health <= 0) {
          enemies.splice(i, 1);   // hapus musuh dari array
          money += 50;            // kasih reward kill dasar
          
          // ğŸ”¥ Extra reward jika ada boost tinggi (Level 4+)
          if (hasBoost && boostLevel >= 4) {
            money += 10; // bonus 10 uang per kill
            // âŒ TIDAK ADA FLOATING TEXT UNTUK BONUS MONEY
          }
        }
      }
    }
    
    // ğŸ”¥ EFEK VISUAL BOM
    if (hasBoost) {
      // Visual explosion effect (lingkaran)
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      
      // Warna berdasarkan boost level
      if (boostLevel >= 4) {
        // Boost tinggi: warna merah-orange dengan glow
        ctx.strokeStyle = "rgba(255, 69, 0, 0.5)";
        ctx.lineWidth = 6;
        ctx.shadowColor = "#FF4500";
        ctx.shadowBlur = 20;
      } else if (boostLevel >= 3) {
        // Boost medium: warna orange
        ctx.strokeStyle = "rgba(255, 165, 0, 0.5)";
        ctx.lineWidth = 5;
        ctx.shadowColor = "#FFA500";
        ctx.shadowBlur = 15;
      } else {
        // Boost rendah: warna kuning
        ctx.strokeStyle = "rgba(255, 215, 0, 0.5)";
        ctx.lineWidth = 4;
        ctx.shadowColor = "#FFD700";
        ctx.shadowBlur = 10;
      }
      
      ctx.stroke();
      ctx.shadowBlur = 0; // reset shadow
      
      // ğŸ”¥ EFEK VISUAL PUSAT BOM (warna hijau jika ada boost)
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = "#00FF00";
      ctx.fill();
      
      // âŒ TIDAK ADA FLOATING TEXT HIT COUNT
    } else {
      // Efek visual tanpa boost
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = "#FF0000";
      ctx.fill();
    }
  }
  return; // biar Bombi nggak spawn peluru
}
   
  if(this.type === 'timemage'){
  if(now - this.lastShot >= this.cooldown){
    // Efek area slow
    enemies.forEach(e => {
      if(Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range){
        e.slowUntil = Date.now() + 3000; // slow 3 detik
      }
    });
    // Visual cast
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.range, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(0,200,255,0.4)";
    ctx.lineWidth = 3;
    ctx.stroke();

    this.lastShot = now;
  }
  return;
}

    if (this.type === 'homesweet') {
  const now = Date.now();
  
  // 1. PELURU PINK (range sesuai level)
  if (now - this.lastShot >= this.cooldown) {
    // Cari target dalam range peluru
    const bulletTarget = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    
    if (bulletTarget) {
      bullets.push({ 
        x: this.x, 
        y: this.y, 
        target: bulletTarget, 
        damage: this.damage,
        color: "#FF69B4"
      });
      this.lastShot = now;
    }
  }
  
  // 2. LASER PINK (range laserRange)
  if (now - this.lastLaser >= this.cooldown) {
    // Cari target dalam range laser
    const laserTarget = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.laserRange
    );
    
    if (laserTarget) {
      // Damage laser lebih kuat
      laserTarget.takeDamage(this.damage * 1.5);
      
      // Visual laser
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(laserTarget.pos.x, laserTarget.pos.y);
      ctx.strokeStyle = "#FF69B4";
      ctx.lineWidth = 3;
      ctx.stroke();
      
      this.lastLaser = now;
    }
  }
  
  // 3. SUMMON LOVE (range summonRange, cooldown 5 detik)
  if (now - this.lastLoveSpawn >= 5000) {
    // Cari target dalam range summon
    const loveTarget = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.summonRange
    );
    
    if (loveTarget) {
      // Panggil method summonLove
      this.summonLove();
      this.lastLoveSpawn = now;
    }
  }
  
  return;
}

    if (this.type === "satellite") {
  if (now - this.lastShot >= this.cooldown) {
    const target = enemies.find(e =>
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );
    if (target) {
      bullets.push({ x: this.x, y: this.y, target: target, damage: this.damage });
      this.lastShot = now;
    }
  }
  return;
}

    if (this.type === 'ball') {
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    // cari 1 musuh terdekat dalam range
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );

    if (target) {
      // ğŸ”¥ HITUNG DAMAGE DENGAN CEK BOOST (sekali saja per salvo)
      let finalDmg = this.damage;
      let hasBoost = false;
      
      const activeBoost = towers.find(t =>
        t.type === "boost" &&
        Math.hypot(t.x - this.x, t.y - this.y) < t.range
      );
      
      if (activeBoost) {
        const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
        finalDmg = Math.floor(finalDmg * bonusMap[activeBoost.level]);
        hasBoost = true;
      }
      
      // spawn 3 peluru dengan jeda 0.5 detik
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          if (enemies.includes(target)) { // cek musuh masih ada
            
            // ğŸ”¥ Tambahkan efek visual khusus jika kena boost
            if (hasBoost && i === 0) { // hanya sekali per salvo
              // Efek visual boost pada tower
              ctx.beginPath();
              ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
              ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
              ctx.lineWidth = 3;
              ctx.stroke();
              
              // Floating text bonus
              floatingTexts.push({
                x: this.x,
                y: this.y - 20,
                text: "ğŸ”¥ BOOSTED!",
                alpha: 1,
                time: Date.now()
              });
            }
            
            bullets.push({
              x: this.x,
              y: this.y,
              target: target,
              damage: finalDmg,
              color: hasBoost ? "#FFD700" : undefined // emas jika boosted
            });
          }
        }, i * 500); // 0.5 detik jeda antar tembakan
      }
    }
  }
  return;
}

    // Di dalam method update(), tambahkan sebelum default logic:
if (this.type === 'console') {
  // Console tidak menembak otomatis, hanya manual via tombol
  // Cek cooldown manual
  if (this.lastManualShot && Date.now() - this.lastManualShot < this.manualCooldown) {
    return;
  }
  return; // Console tidak melakukan apapun di update otomatis
}

    if (this.type === 'laser') {
  if (now - this.lastShot >= this.cooldown) {
    // Cari musuh dalam range
    const target = enemies.find(e => 
      Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
    );

    if (target) {
      // ğŸ”¥ HITUNG DAMAGE DENGAN CEK BOOST
      let finalDmg = this.damage;
      
      const activeBoost = towers.find(t =>
        t.type === "boost" &&
        Math.hypot(t.x - this.x, t.y - this.y) < t.range
      );
      
      if (activeBoost) {
        const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
        finalDmg = Math.floor(finalDmg * bonusMap[activeBoost.level]);
        
        // Efek visual saat kena boost
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
        ctx.fill();
      }
      
      // Serang target dengan damage final
      target.takeDamage(finalDmg);

      // Efek visual laser (warna beda kalau kena boost)
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(target.pos.x, target.pos.y);
      
      if (activeBoost) {
        ctx.strokeStyle = "#00FF00"; // hijau jika kena boost
        ctx.lineWidth = 3.5; // lebih tebal
      } else {
        ctx.strokeStyle = "red"; // merah normal
        ctx.lineWidth = 2.5;
      }
      
      ctx.stroke();
      
      // Floating text damage
      floatingTexts.push({
        x: target.pos.x,
        y: target.pos.y - 20,
        text: `-${finalDmg}`,
        alpha: 1,
        time: Date.now()
      });
    }

    this.lastShot = now;
  }
  return;
}

    if (this.type === 'cupid') {
  if (now - this.lastShot >= this.cooldown) {
    // Cari musuh dalam range (lurus dari Cupid â†’ ke kanan)
    const hits = enemies.filter(e => 
      e.pos.x > this.x && Math.abs(e.pos.y - this.y) < 20 && 
      e.pos.x - this.x <= this.range
    );

    hits.forEach(e => {
      e.takeDamage(this.damage);
      if (e.health <= 0) {
        const i = enemies.indexOf(e);
        if (i !== -1) enemies.splice(i, 1);
        money += 50;
      }
    });

    // Tambah efek visual panah
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.range, this.y);
    ctx.strokeStyle = "pink";
    ctx.lineWidth = 3;
    ctx.stroke();

    this.lastShot = now;
  }
  return;
}

    else if (this.type === 'neptun') {
  if (now - this.lastShot >= this.cooldown) {
    this.lastShot = now;

    if (this.mode === "jin") {
      // Mode AoE
      enemies.forEach(e => {
        if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range) {
          e.takeDamage(this.damage); 
        }
      });
    } else {
      const target = enemies.find(e =>
        Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
      );
      if (target) {
        bullets.push({ x: this.x, y: this.y, target: target, damage: this.damage });
      }
    }
  }
  
  // ğŸŒŠ Skill summon ombak setiap 15 detik
  if (!this.lastSummon) this.lastSummon = 0;
  if (now - this.lastSummon >= 15000) { // 15 detik
    // Buat ombak baru
    const ombak = new OmbakSummon(this.level);
    summons.push(ombak);
    
    // Floating text notifikasi
    floatingTexts.push({
      x: this.x,
      y: this.y - 30,
      text: `ğŸŒŠ Ombak!`,
      alpha: 1,
      time: now
    });
    
    this.lastSummon = now;
  }
  return;
}

    if (this.type === 'falconer') {
  if (!this.falcon) {
    this.falcon = new Falcon(this);   // bikin 1 elang, sekali saja
    summons.push(this.falcon);
  }
  return; // Falconer tidak menembak peluru biasa
}
   if (this.type === 'farmer') {
  return; // farmer tidak melakukan apapun di update
}

    // --- Tower lain: logika standar menembak / memanggil summon ---
    if(now - this.lastShot < this.cooldown) return;

    const targets = enemies.filter(e => Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range);
    if(targets.length === 0) return;

     if(this.type === 'speaker' || this.type === 'programmer'){ 
  targets.forEach(e => {
    if(e.health > 0){                     // âœ… Cek dulu musuh masih hidup
      e.takeDamage(this.damage);
      if(e.health <= 0){                   // âœ… Kalau mati, hapus musuh + kasih uang
        const i = enemies.indexOf(e);
        if(i !== -1) enemies.splice(i, 1);
        money += 50;
      }
      if(this.type === 'programmer'){
        e.slowUntil = Date.now() + 1000; 
      }
    }
  });
  this.lastShot = now;   
} else if(this.type === 'chef'){   // <-- gak ada } dobel disini
  const primary = targets[0];
  bullets.push({ x: this.x, y: this.y, target: primary, damage: this.damage, splash: true });

} else if(this.type === 'lovers'){
  if(now - this.lastSpawn >= this.cooldown){
    summons.push(new Summon(this.x, this.y, 100 + 50 * this.level));
    this.lastSpawn = now;
  }

} else {
  // ğŸ”‹ Hitung damage dengan cek boost
  let dmg = this.damage;

  const activeBoost = towers.find(t =>
    t.type === "boost" &&
    Math.hypot(t.x - this.x, t.y - this.y) < t.range
  );

  if (activeBoost) {
    const bonusMap = {1:1.2, 2:1.3, 3:1.4, 4:1.5, 5:1.6};
    dmg = Math.floor(dmg * bonusMap[activeBoost.level]);
  }

  bullets.push({ x: this.x, y: this.y, target: targets[0], damage: dmg });
}

    this.lastShot = now;
 } 

  draw(){
  ctx.font = '24px serif';
  ctx.fillText(this.emoji, this.x - 10, this.y + 10);

  // ğŸ’« Kasih tanda kalau tower lagi ke-stun
  if (this.stunnedUntil && Date.now() < this.stunnedUntil) {
    ctx.font = '20px serif';
    ctx.fillText("ğŸ’«", this.x, this.y - 25);
  }

 // ğŸŸ¢ CODE BARU - Star dengan visual â˜€ sesuai jumlah ammo
if (this.type === 'star') {
  const now = Date.now();
  
  // ğŸ”¥ HOTBAR RECHARGE DI ATAS STAR (BIRU)
  const barWidth = 40;
  const barHeight = 6;
  const x = this.x - barWidth/2;
  const y = this.y - 45; // POSISI DI ATAS STAR
  
  // Background bar (hitam)
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, barWidth, barHeight);
  
  // Hitung progress recharge untuk peluru berikutnya
  let rechargeProgress = 0;
  if (this.currentAmmo < this.maxAmmo) {
    // Jika sedang recharge, hitung progress berdasarkan waktu
    const timeSinceLastRecharge = now - (this.lastRecharge || now);
    rechargeProgress = Math.min(1, timeSinceLastRecharge / this.rechargeRate);
  } else {
    // Jika ammo penuh, progress = 1 (full)
    rechargeProgress = 1;
  }
  
  // Hotbar recharge (BIRU) - menunjukkan progress ke peluru berikutnya
  ctx.fillStyle = '#00BFFF'; // Biru terang
  ctx.fillRect(x, y, barWidth * rechargeProgress, barHeight);
  
  // Border hotbar
  ctx.strokeStyle = '#FFF';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, barWidth, barHeight);
  
  // ğŸ”¥ AMMO BAR DI BAWAH (untuk jumlah peluru yang tersedia)
  const ammoBarY = this.y + 15;
  
  // Background ammo bar
  ctx.fillStyle = '#333';
  ctx.fillRect(x, ammoBarY, barWidth, barHeight);
  
  // Ammo bar (biru lebih gelap untuk membedakan)
  const ammoPercentage = this.currentAmmo / this.maxAmmo;
  ctx.fillStyle = '#4169E1'; // Royal Blue (lebih gelap dari hotbar recharge)
  ctx.fillRect(x, ammoBarY, barWidth * ammoPercentage, barHeight);
  
  // Border ammo bar
  ctx.strokeStyle = '#FFF';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, ammoBarY, barWidth, barHeight);
  
  // ğŸ”¥ VISUAL â˜€ BERDASARKAN JUMLAH AMMO
  ctx.font = '20px serif';
  ctx.fillStyle = '#FFD700'; // Warna emas
  ctx.shadowColor = '#FFA500';
  ctx.shadowBlur = 8;
  
  // Posisi untuk 5 â˜€ (melingkar di sekitar tower)
  const positions = [
    { x: this.x - 30, y: this.y - 25 }, // kiri atas
    { x: this.x + 30, y: this.y - 25 }, // kanan atas
    { x: this.x - 30, y: this.y + 30 }, // kiri bawah
    { x: this.x + 30, y: this.y + 30 }, // kanan bawah
    { x: this.x, y: this.y - 40 }       // tengah atas
  ];
  
  // Tampilkan â˜€ sesuai jumlah currentAmmo
  for (let i = 0; i < this.currentAmmo; i++) {
    const pos = positions[i];
    ctx.fillText('â˜€', pos.x, pos.y);
  }
  
  ctx.shadowBlur = 0;
  
  // ğŸ”¥ OPSIONAL: Tampilkan setengah transparan untuk ammo yang sedang recharge
  if (this.currentAmmo < this.maxAmmo && rechargeProgress > 0 && rechargeProgress < 1) {
    // Tampilkan â˜€ dengan opacity sesuai progress untuk peluru yang sedang di-recharge
    ctx.globalAlpha = rechargeProgress * 0.7; // Transparan sesuai progress
    ctx.fillStyle = '#FFD700';
    ctx.shadowBlur = 8;
    
    // Posisi untuk peluru yang sedang di-recharge (posisi ke-(currentAmmo))
    if (this.currentAmmo < 5) {
      const nextPos = positions[this.currentAmmo];
      ctx.fillText('â˜€', nextPos.x, nextPos.y);
    }
    
    ctx.globalAlpha = 1.0;
    ctx.shadowBlur = 0;
  }
}

  if(selectedUnit === this){
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.range, 0, 2 * Math.PI);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.stroke();
  }
}
}

   Tower.prototype.copyRandomUnit = function() {
  // Daftar semua unit yang bisa dicopy (kecuali camera itu sendiri)
  const copyableUnits = [];
  
  // Loop melalui semua kategori unit
  for (const category in unitSets) {
    unitSets[category].forEach(unit => {
      if (unit.type !== 'camera' && unit.type !== this.originalType) {
        copyableUnits.push(unit);
      }
    });
  }
  
  // Juga include unit special yang sudah di-unlock
  const specialUnits = ['god', 'neptun', 'circus', 'homesweet'].filter(
    unit => unlockedUnits[unit]
  );
  
  if (copyableUnits.length > 0) {
    // Pilih unit random untuk dicopy
    const randomUnit = copyableUnits[Math.floor(Math.random() * copyableUnits.length)];
    this.copiedFrom = randomUnit.type;
    this.copiedEmoji = randomUnit.emoji;
    this.emoji = '...'; // Tampilkan "..." saat sedang meniru
    
    // Set stats dasar untuk camera copy
    this.copiedDamage = 30 + (this.level - 1) * 15;
    this.copiedRange = 120 + (this.level - 1) * 20;
    this.copiedCooldown = 2000 - (this.level - 1) * 200;
    
    // Inisialisasi properti khusus untuk unit ekonomi
    this.lastEconomicAction = 0;
    this.copyIncome = 0;
    this.copySellValue = 250;
    this.copyCreatedAt = Date.now();
    this.lastValueIncrease = Date.now();
    
    // Reset timer untuk skill copy
    this.lastCopyAction = 0;
    
    // Floating text
    floatingTexts.push({
      x: this.x,
      y: this.y - 20,
      text: `ğŸ“· â†’ ${randomUnit.emoji}`,
      alpha: 1,
      time: Date.now()
    });
   
  }
};

Tower.prototype.simulateCopiedUnit = function() {
  if (!this.copiedFrom) return;
  
  const now = Date.now();
  
  // Update emoji setelah delay 0.5 detik
  if (now - this.lastCopyTime < 500) {
    this.emoji = '...';
  } else {
    this.emoji = this.copiedEmoji;
  }
  
  // === UNIT EKONOMI & KHUSUS ===
  switch(this.copiedFrom) {
    // === UNIT EKONOMI ===
    case 'bitcoin':
      // Bitcoin: naik nilai seiring waktu (50% dari aslinya)
      if (now - this.lastValueIncrease >= 10000) { // setiap 10 detik
        this.copySellValue += 25; // 50% dari kenaikan asli
        this.lastValueIncrease = now;
        
        // Efek visual kenaikan nilai
        if (Math.random() < 0.2) {
          floatingTexts.push({
            x: this.x,
            y: this.y - 20,
            text: `ğŸª™+25`,
            alpha: 1,
            time: now
          });
        }
      }
      break;
      
    case 'farmer':
      // Farmer: menghasilkan uang (50% dari aslinya)
      if (now - this.lastEconomicAction >= 15000) { // CD 15 detik
        const farmerGain = 10 + (this.level - 1) * 5; // 50% dari gain asli
        money += farmerGain;
        
        floatingTexts.push({
          x: this.x,
          y: this.y - 20,
          text: `ğŸ‘¨â€ğŸŒ¾+${farmerGain}`,
          alpha: 1,
          time: now
        });
        
        this.lastEconomicAction = now;
      }
      break;
      
    case 'printer':
      // Printer: menghasilkan uang (40% dari aslinya)
      if (now - this.lastEconomicAction >= 15000) { // CD 15 detik
        const printerIncome = 8 + (this.level - 1) * 4; // 40% dari asli
        money += printerIncome;
        
        floatingTexts.push({
          x: this.x,
          y: this.y - 20,
          text: `ğŸ–¨ï¸+${printerIncome}`,
          alpha: 1,
          time: now
        });
        
        this.lastEconomicAction = now;
      }
      break;
      
    case 'judi':
      // Judi: efek random (50% lebih lemah dari aslinya)
      if (now - this.lastCopyAction >= 8000) { // CD 8 detik
        const randomEffect = Math.floor(Math.random() * 5);
        let message = "ğŸ“· Judi: ";
        
        switch(randomEffect) {
          case 0:
            // Damage ke musuh terdekat
            const enemy = enemies.find(e => 
              Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
            );
            if (enemy) {
              enemy.takeDamage(this.copiedDamage);
              message += "Damage!";
            }
            break;
          case 1:
            // Bonus uang (50% dari aslinya)
            const bonusMoney = Math.floor(Math.random() * 101) + 50; // 50-150
            money += bonusMoney;
            message += `+${bonusMoney}ğŸ’°`;
            break;
          case 2:
            // Slow musuh terdekat
            enemies.forEach(e => {
              if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
                e.slowUntil = now + 1500;
                e.slowMultiplier = 0.85;
              }
            });
            message += "Slow!";
            break;
          case 3:
            // Heal base (25% dari aslinya)
            baseHP = Math.min(500, baseHP + 25);
            message += "Heal base!";
            break;
          case 4:
            // Efek negatif: kehilangan uang kecil
            money = Math.max(0, money - 50);
            message += "Rugi 50ğŸ’°";
            break;
        }
        
        showNotification(message);
        this.lastCopyAction = now;
      }
      break;

    case 'cupid':
      // Cupid: piercing shot
      if (now - this.lastCopyAction >= 1500) {
        const hits = enemies.filter(e => 
          e.pos.x > this.x && Math.abs(e.pos.y - this.y) < 20 && 
          e.pos.x - this.x <= this.copiedRange
        );
        hits.forEach(e => e.takeDamage(this.copiedDamage));
        
        // Visual piercing line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.copiedRange, this.y);
        ctx.strokeStyle = "pink";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        this.lastCopyAction = now;
      }
      break;
      
    case 'laser':
      // Laser: laser beam
      if (now - this.lastCopyAction >= 300) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage * 0.7); // 70% damage dari aslinya
          
          // Efek visual laser
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(target.pos.x, target.pos.y);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.stroke();
          
          this.lastCopyAction = now;
        }
      }
      break;

    case 'astronaut':
      // Astronaut: summon flags/moon
      if (now - this.lastCopyAction >= 5000) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        
        if (target) {
          const rand = Math.random();
          
          if (rand < 0.7) {
            summons.push(new FlagSummon(this.x, this.y, "white", target, this));
          } else if (rand < 0.95) {
            summons.push(new FlagSummon(this.x, this.y, "red", target, this));
          } else {
            summons.push(new MoonSummon(this.x, this.y, target, this));
          }
          
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'bombi':
      // Bombi: AoE explosion
      if (now - this.lastCopyAction >= 6000) {
        enemies.forEach(e => {
          if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
            e.takeDamage(this.copiedDamage * 2);
          }
        });
        
        // Visual explosion
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.copiedRange, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
        ctx.lineWidth = 3;
        ctx.stroke();
        
        this.lastCopyAction = now;
      }
      break;
      
    case 'scientist':
      // Scientist: barrier
      if (now - this.lastCopyAction >= 10000) {
        const candidates = closestPointsOnPathWithinRange(this.x, this.y, this.copiedRange);
        if (candidates.length > 0) {
          const c = candidates[Math.floor(Math.random() * candidates.length)];
          barriers.push(new Barrier(c.x, c.y, 200));
        }
        this.lastCopyAction = now;
      }
      break;
      
    case 'satellite':
      // Satellite: fast shooting
      if (now - this.lastCopyAction >= 1200) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage * 0.8 
          });
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'wrench':
      // Wrench: spawn turret
      if (now - this.lastCopyAction >= 8000) { // CD 8 detik
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          // Buat turret sementara
          const turret = {
            x: target.pos.x,
            y: target.pos.y,
            type: "turret_copy",
            emoji: "ğŸ“¬",
            damage: 20,
            range: 80,
            cooldown: 1000,
            lastShot: 0,
            createdAt: now,
            lifetime: 10000, // 10 detik
            update: function() {
              if (now - this.createdAt >= this.lifetime) {
                return false; // hapus nanti
              }
              if (now - this.lastShot >= this.cooldown) {
                const target = enemies.find(e => 
                  Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.range
                );
                if (target) {
                  bullets.push({ 
                    x: this.x, 
                    y: this.y, 
                    target: target, 
                    damage: this.damage 
                  });
                  this.lastShot = now;
                }
              }
              return true;
            },
            draw: function() {
              ctx.font = '20px serif';
              ctx.fillText(this.emoji, this.x - 8, this.y + 8);
            }
          };
          
          // Simpan ke array temporary
          if (!window.tempTowers) window.tempTowers = [];
          window.tempTowers.push(turret);
          
          showNotification("ğŸ“· Camera: Turret sementara dibuat!");
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'hook':
      // Hook: pull enemy + teleport chance
      if (now - this.lastCopyAction >= 3000) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage);
          
          // 15% chance teleport back
          if (Math.random() < 0.15) {
            if (target.pathIndex > 0) {
              target.pathIndex = Math.max(0, target.pathIndex - 2);
              const prevPoint = target.path[target.pathIndex];
              target.pos = { ...prevPoint };
              
              floatingTexts.push({
                x: target.pos.x,
                y: target.pos.y - 20,
                text: "ğŸŒ€",
                alpha: 1,
                time: now
              });
            }
          }
          
          // Slow
          target.slowUntil = now + 800;
          target.slowMultiplier = 0.8;
          
          // Peluru visual
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage,
            color: "#8B4513"
          });
          
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'console':
      // Console: enable manual shooting button
      if (activeConsole === null) {
        activeConsole = this;
        showNotification("ğŸ“· Camera: Console skill aktif! Gunakan tombol 'âœ´ï¸ Tembak Console'");
      }
      break;
      
    case 'clock':
      // Clock: AoE damage
      if (now - this.lastCopyAction >= 3000) {
        const targets = enemies.filter(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        
        if (targets.length > 0) {
          targets.forEach(e => {
            e.takeDamage(this.copiedDamage);
          });
          
          // Visual AoE
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.copiedRange, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(0, 200, 255, 0.3)";
          ctx.lineWidth = 3;
          ctx.stroke();
          
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'koboi':
      // Koboi: double shot
      if (now - this.lastCopyAction >= 3000) {
        // Piercing shot
        const hits = enemies.filter(e => 
          e.pos.x > this.x && Math.abs(e.pos.y - this.y) < 20 && 
          e.pos.x - this.x <= this.copiedRange
        );

        hits.forEach(e => {
          e.takeDamage(this.copiedDamage * 0.8);
        });

        // Double shot
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < (this.copiedRange - 50)
        );

        if (target) {
          for (let i = 0; i < 2; i++) {
            setTimeout(() => {
              if (enemies.includes(target)) {
                bullets.push({
                  x: this.x,
                  y: this.y,
                  target: target,
                  damage: this.copiedDamage * 0.8
                });
              }
            }, i * 400);
          }
        }

        // Visual piercing line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.copiedRange, this.y);
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 2;
        ctx.stroke();

        this.lastCopyAction = now;
      }
      break;
      
    case 'police':
      // Police: summon dog
      if (now - this.lastCopyAction >= 4000) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          summons.push(new DogSummon(this.x, this.y, target, this.copiedDamage));
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'ball':
      // Ball: triple shot
      if (now - this.lastCopyAction >= 3500) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (enemies.includes(target)) {
                bullets.push({
                  x: this.x,
                  y: this.y,
                  target: target,
                  damage: this.copiedDamage
                });
              }
            }, i * 300);
          }
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'dadu':
      // Dadu: efek random (60% dari aslinya)
      if (now - this.lastCopyAction >= 12000) { // CD 12 detik
        const randomEffect = Math.floor(Math.random() * 5);
        let message = "ğŸ“· Dadu: ";
        
        switch(randomEffect) {
          case 0:
            // Damage ke semua musuh dalam range
            enemies.forEach(e => {
              if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
                e.takeDamage(this.copiedDamage * 1.2);
              }
            });
            message += "Area damage!";
            break;
          case 1:
            // Bonus uang besar
            const bigBonus = 100 + (this.level * 25);
            money += bigBonus;
            message += `+${bigBonus}ğŸ’°`;
            break;
          case 2:
            // Stun musuh terdekat
            enemies.forEach(e => {
              if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
                e.stunnedUntil = now + 2000;
              }
            });
            message += "Stun!";
            break;
          case 3:
            // Teleport musuh mundur
            enemies.forEach(e => {
              if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange && e.pathIndex > 0) {
                e.pathIndex = Math.max(0, e.pathIndex - 2);
                const prevPoint = e.path[e.pathIndex];
                e.pos = { ...prevPoint };
              }
            });
            message += "Teleport back!";
            break;
          case 4:
            // Efek campuran: damage kecil + bonus uang
            enemies.forEach(e => {
              if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
                e.takeDamage(this.copiedDamage * 0.5);
              }
            });
            money += 75;
            message += "Mix: dmg + money!";
            break;
        }
        
        showNotification(message);
        this.lastCopyAction = now;
      }
      break;
      
    case 'boost':
      // Boost: meningkatkan damage tower sekitar (75% efektivitas asli)
      // Tidak perlu logika khusus, efek akan diterapkan di logika damage tower
      if (now - this.lastCopyAction >= 5000) {
        // Efek visual aura boost
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.copiedRange, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(0, 255, 0, 0.2)";
        ctx.lineWidth = 2;
        ctx.stroke();
        this.lastCopyAction = now;
      }
      break;
      
    case 'priest':
      // Priest: heal base (50% dari aslinya)
      if (now - this.lastCopyAction >= 10000) { // CD 10 detik
        const healAmount = 10 + (this.level * 2); // 50% dari heal asli
        baseHP = Math.min(500, baseHP + healAmount);
        
        floatingTexts.push({
          x: this.x,
          y: this.y - 20,
          text: `â›ª+${healAmount}HP`,
          alpha: 1,
          time: now
        });
        
        this.lastCopyAction = now;
      }
      break;
      
    case 'vampire':
      // Vampire: summon vampire (50% HP dari asli)
      if (now - this.lastCopyAction >= 24000) { // CD 24 detik
        const vampireSummon = new VampireSummon(this.level);
        vampireSummon.maxHealth = 100 + (25 * (this.level - 1));
        vampireSummon.health = vampireSummon.maxHealth;
        vampireSummon.pos = { x: this.x + 20, y: this.y };
        
        if (Array.isArray(path[0])) {
          const p = path[0]; 
          vampireSummon.path = [...p].reverse();
        } else {
          vampireSummon.path = [...path].reverse();
        }
        
        summons.push(vampireSummon);
        this.lastCopyAction = now;
      }
      break;
      
    case 'chef':
      // Chef: splash damage (60% dari asli)
      if (now - this.lastCopyAction >= 4500) { // CD 4.5 detik
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage,
            splash: true 
          });
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'speaker':
      // Speaker: AoE damage (70% dari asli)
      if (now - this.lastCopyAction >= 2100) { // CD 2.1 detik
        enemies.forEach(e => {
          if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
            e.takeDamage(this.copiedDamage * 0.7);
          }
        });
        this.lastCopyAction = now;
      }
      break;
      
    case 'programmer':
      // Programmer: damage + slow (60% dari asli)
      if (now - this.lastCopyAction >= 3000) { // CD 3 detik
        enemies.forEach(e => {
          if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
            e.takeDamage(this.copiedDamage * 0.6);
            e.slowUntil = now + 800; // Slow lebih pendek
          }
        });
        this.lastCopyAction = now;
      }
      break;
      
    case 'sword':
      // Sword: basic attack (80% dari asli)
      if (now - this.lastCopyAction >= 2400) { // CD 2.4 detik
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage * 0.8);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage * 0.8 
          });
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'archer':
      // Archer: ranged attack (75% dari asli)
      if (now - this.lastCopyAction >= 3600) { // CD 3.6 detik
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage * 0.75);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage * 0.75 
          });
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'sniper':
      // Sniper: high damage single target (50% dari asli)
      if (now - this.lastCopyAction >= 7500) { // CD 7.5 detik
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage * 2);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage * 2 
          });
          this.lastCopyAction = now;
        }
      }
      break;
      
    case 'lovers':
      // Lovers: summon (50% HP dari asli)
      if (now - this.lastCopyAction >= 15000) { // CD 15 detik
        const loverSummon = new Summon(this.x, this.y, 50 + (10 * this.level));
        summons.push(loverSummon);
        this.lastCopyAction = now;
      }
      break;
      
    // === UNIT KHUSUS DENGAN SKILL UNIK ===
    case 'god':
      // God: summon musuh random
      if (now - this.lastCopyAction >= 20000) { // CD 20 detik
        const enemyTypes = ['hearts', 'furry', 'shield', 'ninja', 'speedrun', 'angry'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const summon = new GodSummon(type);
        summon.pos = { x: this.x + 20, y: this.y };
        summon.maxHealth = 1200;
        summon.health = 1200;
        summons.push(summon);
        this.lastCopyAction = now;
      }
      break;
      
    case 'neptun':
      // Neptun: mode switching
      if (!this.copyMode) this.copyMode = "neptun";
      if (now - this.lastCopyAction >= this.copiedCooldown) {
        if (this.copyMode === "jin") {
          // AoE damage
          enemies.forEach(e => {
            if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange) {
              e.takeDamage(this.copiedDamage);
            }
          });
        } else {
          // Single target
          const target = enemies.find(e => 
            Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
          );
          if (target) {
            target.takeDamage(this.copiedDamage);
            bullets.push({ 
              x: this.x, 
              y: this.y, 
              target: target, 
              damage: this.copiedDamage 
            });
          }
        }
        this.lastCopyAction = now;
      }
      break;
      
    case 'circus':
      // Circus: summon random
      if (now - this.lastCopyAction >= 15000) { // CD 15 detik
        const types = ['ğŸšµâ€â™€ï¸', 'ğŸ§—â€â™‚ï¸', 'ğŸ„â€â™‚ï¸', 'â›·ï¸'];
        const type = types[Math.floor(Math.random() * types.length)];
        const hp = type === 'â›·ï¸' ? 1200 : 300;
        const summon = new CircusSummon(this.x, this.y, type, hp);
        summons.push(summon);
        this.lastCopyAction = now;
      }
      break;
      
    case 'homesweet':
      // Homesweet: peluru pink + laser
      if (now - this.lastCopyAction >= 3000) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage,
            color: "#FF69B4"
          });
          
          this.lastCopyAction = now;
        }
      }
      break;
      
    // === DEFAULT ATTACK UNTUK UNIT LAIN ===
    default:
      // Untuk unit biasa: tembak normal (70% efektivitas)
      if (now - this.lastCopyAction >= 2500) {
        const target = enemies.find(e => 
          Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.copiedRange
        );
        if (target) {
          target.takeDamage(this.copiedDamage * 0.7);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            target: target, 
            damage: this.copiedDamage * 0.7 
          });
          this.lastCopyAction = now;
        }
      }
  }
};

    class Summon {
      constructor(x, y, health){
        this.pos = {x, y};
        this.health = health;
        this.speed = 1.5;
      }
      update(){
  if(enemies.length === 0) return;
  let target = enemies[0];
  const dx = target.pos.x - this.pos.x;
  const dy = target.pos.y - this.pos.y;
  const dist = Math.hypot(dx, dy);

  if(dist < 10){
    target.health -= this.health;
    if(target.health <= 0){
      enemies.splice(enemies.indexOf(target), 1);
      money += 50;
    }
    // Summon hilang setelah nyerang
    summons.splice(summons.indexOf(this), 1);
  } else {
    this.pos.x += dx / dist * this.speed;
    this.pos.y += dy / dist * this.speed;
  }
      }
      draw(){
        ctx.font = '24px serif';
        ctx.fillText('ğŸ§â€â™‚', this.pos.x, this.pos.y);
        ctx.font = '14px sans-serif';
        ctx.fillStyle = 'white';
        ctx.fillText(`${this.health}`, this.pos.x, this.pos.y - 10);
      }
    }

     class OmbakSummon {
  constructor(level){
    this.level = level;
    this.damage = 100; // damage tetap 100 setiap musuh yang lewat
    this.speed = 0.5;
    this.emoji = "ğŸŒŠ";
    this.lastDamageTime = 0;
    this.damageCooldown = 500; // 0.5 detik cooldown damage ke musuh yang sama

    // posisi awal dari base (ujung path) - REVERSE PATH
    if (Array.isArray(path[0])) {
      const p = path[0]; 
      this.pos = {...p[p.length - 1]};
      this.path = [...p].reverse();
    } else {
      this.pos = {...path[path.length - 1]};
      this.path = [...path].reverse();
    }
    this.pathIndex = 0;
  }

  update(){
    const next = this.path[this.pathIndex + 1];
    if(!next) {
      // sampai ke ujung (spawn point) â†’ hilang
      summons.splice(summons.indexOf(this), 1);
      return;
    }

    // Gerak maju di reverse path
    const dx = next.x - this.pos.x;
    const dy = next.y - this.pos.y;
    const dist = Math.hypot(dx, dy);

    if(dist < this.speed){
      this.pos = {...next};
      this.pathIndex++;
    } else {
      this.pos.x += dx / dist * this.speed;
      this.pos.y += dy / dist * this.speed;
    }

    // Damage ke musuh yang dilewati
    const now = Date.now();
    for (let e of enemies){
      if(Math.hypot(e.pos.x - this.pos.x, e.pos.y - this.pos.y) < 30){
        
        // Cek cooldown damage untuk musuh ini
        if (!e.lastOmbakDamage || now - e.lastOmbakDamage >= this.damageCooldown) {
          e.takeDamage(this.damage);
          e.lastOmbakDamage = now;
          
          // âŒ FLOATING TEXT DAMAGE DIHAPUS - tidak menampilkan "-100"

          // Cek jika musuh mati
          if (e.health <= 0) {
            const idx = enemies.indexOf(e);
            if (idx !== -1) {
              enemies.splice(idx, 1);
              money += 50;
            }
          }
        }
      }
    }
  }

  draw(){
    ctx.font = "28px serif";
    ctx.fillText(this.emoji, this.pos.x, this.pos.y);
    
    // Efek visual ombak (lingkaran bergelombang)
    const now = Date.now();
    const wavePhase = (now % 1000) / 1000; // 0-1 setiap 1 detik
    
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, 20 + wavePhase * 10, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(0, 100, 255, 0.3)";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, 25 + wavePhase * 10, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(0, 150, 255, 0.2)";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // âœ… Tampilkan damage info (ğŸ’§100) di atas ombak
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "cyan";
    ctx.fillText(`ğŸ’§${this.damage}`, this.pos.x, this.pos.y - 20);
  }
}

     class FlagSummon {
  constructor(x, y, type, target, owner) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.target = target;
    this.owner = owner;
    this.speed = 3;
    
    if (type === "white") {
      this.emoji = "ğŸ³";
      this.damage = 75;
    } else { // red
      this.emoji = "ğŸš©";
      this.damage = 150;
    }
  }

  update() {
    // Cek apakah target masih ada
    if (!enemies.includes(this.target)) {
      const idx = summons.indexOf(this);
      if (idx !== -1) summons.splice(idx, 1);
      return;
    }

    // Bergerak menuju target
    const dx = this.target.pos.x - this.x;
    const dy = this.target.pos.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < this.speed) {
      // Hit target
      this.target.takeDamage(this.damage);
      
      // Efek khusus untuk red flag (slow 10%)
      if (this.type === "red") {
        this.target.slowUntil = Date.now() + 2000;
        this.target.slowMultiplier = 0.9;
        
        // TIDAK ADA FLOATING TEXT DI SINI
      }
      
      // Hapus summon setelah menyerang
      const idx = summons.indexOf(this);
      if (idx !== -1) summons.splice(idx, 1);
      return;
    }

    this.x += dx / dist * this.speed;
    this.y += dy / dist * this.speed;
  }

  draw() {
    ctx.font = '24px serif';
    ctx.fillText(this.emoji, this.x, this.y);
  }
}

     class MoonSummon {
  constructor(x, y, target, owner) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.owner = owner;
    this.speed = 2.5;
    this.emoji = "ğŸŒ•";
    this.damage = 1500;
    this.splashRange = 150;
  }

  update() {
    // Cek apakah target masih ada
    if (!enemies.includes(this.target)) {
      const idx = summons.indexOf(this);
      if (idx !== -1) summons.splice(idx, 1);
      return;
    }

    const dx = this.target.pos.x - this.x;
    const dy = this.target.pos.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < this.speed) {
      // SPLASH DAMAGE ke semua musuh dalam radius
      enemies.forEach(e => {
        if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.splashRange) {
          e.takeDamage(this.damage);
        }
      });
      
      // Visual efek splash (tetap tampil)
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.splashRange, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255, 255, 100, 0.5)";
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // TIDAK ADA FLOATING TEXT DI SINI
      
      // Hapus summon setelah menyerang
      const idx = summons.indexOf(this);
      if (idx !== -1) summons.splice(idx, 1);
      return;
    }

    this.x += dx / dist * this.speed;
    this.y += dy / dist * this.speed;
  }

  draw() {
    ctx.font = '28px serif';
    ctx.fillText(this.emoji, this.x, this.y);
    
    // Gambar aura moon
    ctx.beginPath();
    ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(255, 255, 200, 0.3)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

     class LoveSummon {
  constructor(x, y, health, owner) {
    this.x = x;
    this.y = y;
    this.maxHealth = health; // 200
    this.health = health;
    this.speed = 2.0; // Lebih cepat
    this.owner = owner;
    this.emoji = "ğŸ˜";
    this.damage = 0; // Tidak ada damage per hit, langsung sistem tabrak
  }
  
  update() {
    if (enemies.length === 0) return;
    
    // Cari musuh terdekat
    let target = null;
    let minDist = Infinity;
    
    enemies.forEach(e => {
      const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
      if (dist < minDist) {
        minDist = dist;
        target = e;
      }
    });
    
    if (target) {
      const dx = target.pos.x - this.x;
      const dy = target.pos.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      // Jika dalam jarak tabrakan (15px)
      if (dist < 15) {
        // â­â­ SISTEM TABRAK: Love HP vs Musuh HP â­â­
        const enemyHP = target.health;
        
        // Musuh kehilangan HP = HP Love (200)
        target.takeDamage(this.health);
        
        // Love kehilangan HP = HP Musuh
        this.health -= enemyHP;
        
        // Cek jika Love mati
        if (this.health <= 0) {
          const idx = summons.indexOf(this);
          if (idx !== -1) {
            summons.splice(idx, 1);
          }
        }
        
        // Cek jika musuh mati
        if (target.health <= 0) {
          const idx = enemies.indexOf(target);
          if (idx !== -1) {
            enemies.splice(idx, 1);
            money += 50;
          }
        }
        
        return; // Love hilang setelah tabrakan
      }
      
      // Bergerak ke target
      this.x += dx / dist * this.speed;
      this.y += dy / dist * this.speed;
    }
  }
  
  draw() {
    // Gambar emoji love
    ctx.font = '22px serif';
    ctx.fillText(this.emoji, this.x - 11, this.y + 8);
    
    // Health bar kecil
    const healthBarWidth = 30;
    const healthPercentage = this.health / this.maxHealth;
    
    // Background health bar
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 20, healthBarWidth, 4);
    
    // Fill health bar (pink)
    ctx.fillStyle = '#FF69B4';
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 20, healthBarWidth * healthPercentage, 4);
    
    // Border health bar
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 1;
    ctx.strokeRect(this.x - healthBarWidth/2, this.y - 20, healthBarWidth, 4);
    
    // â­â­ TAMPILKAN ANGKA HP (200) â­â­
    ctx.font = '10px sans-serif';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(`${this.health}`, this.x, this.y - 10);
  }
}

    // Tambahkan DI LUAR class Tower, setelah deklarasi class Tower (bisa di bagian bawah file)
Tower.prototype.summonLove = function() {
  const love = new LoveSummon(this.x, this.y, 200, this);
  summons.push(love);
};

// Atau tambahkan di dalam class Tower (tambahkan sebagai method):
Tower.prototype.summonLove = function() {
  const love = new LoveSummon(this.x, this.y, 200, this);
  summons.push(love);
};

     class DogSummon {
  constructor(x, y, target, dmg) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.damage = dmg;
    this.speed = 3;
    this.emoji = "ğŸ¦®";
    this.splashRange = 60; // normal splash range
    this.hasBoost = false; // flag apakah kena boost
    this.boostLevel = 0;
    this.scale = 1.0; // scale normal
  }

  update() {
    if (!enemies.includes(this.target)) {
      summons.splice(summons.indexOf(this), 1);
      return;
    }

    const dx = this.target.pos.x - this.x;
    const dy = this.target.pos.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < this.speed) {
      // ğŸ’¥ ledakan splash
      enemies.forEach(e => {
        if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < this.splashRange) {
          // ğŸ”¥ TAMPILKAN DAMAGE NUMBER JIKA KENA BOOST
          if (this.hasBoost) {
            floatingTexts.push({
              x: e.pos.x,
              y: e.pos.y - 20,
              text: `-${this.damage}`,
              alpha: 1,
              time: Date.now()
            });
          }
          
          e.takeDamage(this.damage);
        }
      });

      // hapus anjing setelah meledak
      summons.splice(summons.indexOf(this), 1);
      return;
    }

    this.x += dx / dist * this.speed;
    this.y += dy / dist * this.speed;
  }

  draw() {
    // ğŸ”¥ UKURAN LEBIH BESAR JIKA KENA BOOST
    const fontSize = this.hasBoost ? "28px" : "22px";
    ctx.font = fontSize + ' serif';
    
    // ğŸ”¥ WARNA BERBEDA BERDASARKAN BOOST LEVEL
    if (this.hasBoost) {
      if (this.boostLevel >= 4) {
        ctx.fillStyle = "#00FF00"; // hijau terang untuk boost tinggi
      } else if (this.boostLevel >= 3) {
        ctx.fillStyle = "#00BFFF"; // biru terang untuk boost medium
      } else {
        ctx.fillStyle = "#FFD700"; // emas untuk boost rendah
      }
    } else {
      ctx.fillStyle = "white"; // putih normal
    }
    
    ctx.fillText(this.emoji, this.x, this.y);
    
    // ğŸ”¥ GAMBAR AURA SPLASH AREA JIKA KENA BOOST
    if (this.hasBoost) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.splashRange, 0, Math.PI * 2);
      
      if (this.boostLevel >= 4) {
        ctx.strokeStyle = "rgba(0, 255, 0, 0.3)";
        ctx.lineWidth = 3;
      } else if (this.boostLevel >= 3) {
        ctx.strokeStyle = "rgba(0, 191, 255, 0.3)";
        ctx.lineWidth = 2.5;
      } else {
        ctx.strokeStyle = "rgba(255, 215, 0, 0.3)";
        ctx.lineWidth = 2;
      }
      
      ctx.stroke();
    }
  }
}

     class GodSummon {
  constructor(type){
    this.type = type;
    this.emoji = new Enemy(type).emoji;
    this.maxHealth = new Enemy(type).maxHealth;
    this.health = this.maxHealth;
    this.speed = new Enemy(type).speed || 1.0;
    this.damage = 0;
    this.lastCollision = 0;
    this.collisionCooldown = 100;

    // Jalur dari base ke spawn (reverse path)
    if (Array.isArray(path[0])) {
      const p = path[0];
      this.pos = {...p[p.length - 1]};
      this.path = [...p].reverse();
    } else {
      this.pos = {...path[path.length - 1]};
      this.path = [...path].reverse();
    }
    this.pathIndex = 0;
  }

  update(){
    const next = this.path[this.pathIndex + 1];
    if (!next) {
      summons.splice(summons.indexOf(this), 1);
      return;
    }

    // Gerak maju
    const dx = next.x - this.pos.x;
    const dy = next.y - this.pos.y;
    const dist = Math.hypot(dx, dy);

    if (dist < this.speed) {
      this.pos = {...next};
      this.pathIndex++;
    } else {
      this.pos.x += dx / dist * this.speed;
      this.pos.y += dy / dist * this.speed;
    }

    // ğŸ”¥ TABRAKAN BERULANG - BISA KE MUSUH BERBEDA
    const now = Date.now();
    
    for (let e of enemies){
      if (Math.hypot(e.pos.x - this.pos.x, e.pos.y - this.pos.y) < 25 && 
          now - this.lastCollision >= this.collisionCooldown) {
        
        // â­â­ LOGIKA PERTUKARAN HP
        const enemyCurrentHP = e.health;
        const cloneCurrentHP = this.health;
        
        // Musuh kehilangan HP sebesar HP clone saat ini
        e.takeDamage(cloneCurrentHP);
        
        // Clone kehilangan HP sebesar HP musuh saat ini
        this.health -= enemyCurrentHP;
        
        // Update timer tabrakan
        this.lastCollision = now;
        
        // â­â­ TIDAK ADA FLOATING TEXT "-HP" ATAU "CLONE HANCUR"
        
        // Cek jika musuh mati
        if (e.health <= 0) {
          const idx = enemies.indexOf(e);
          if (idx !== -1) {
            enemies.splice(idx, 1);
            money += 50;
          }
        }
        
        // Cek jika clone mati
        if (this.health <= 0) {
          const idx = summons.indexOf(this);
          if (idx !== -1) {
            summons.splice(idx, 1);
            // â­â­ TIDAK ADA FLOATING TEXT "ğŸ’€ Clone hancur!"
          }
          return;
        }
        
        // â­ TAMBAH EFEK "KNOCKBACK" - musuh terdorong sedikit
        const pushForce = 10;
        const angle = Math.atan2(e.pos.y - this.pos.y, e.pos.x - this.pos.x);
        e.pos.x += Math.cos(angle) * pushForce;
        e.pos.y += Math.sin(angle) * pushForce;
        
        // Clone juga terdorong sedikit ke arah berlawanan
        this.pos.x -= Math.cos(angle) * (pushForce / 2);
        this.pos.y -= Math.sin(angle) * (pushForce / 2);
        
        break;
      }
    }
  }

  draw(){
    // Gambar clone
    ctx.font = "24px serif";
    ctx.fillText(this.emoji, this.pos.x, this.pos.y);
    
    // â­â­ TIDAK ADA EFEK COOLDOWN VISUAL
    
    // Health bar
    const healthBarWidth = 40;
    const healthPercentage = this.health / this.maxHealth;
    
    // Background
    ctx.fillStyle = '#000';
    ctx.fillRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth, 6);
    
    // Warna berdasarkan HP
    let healthColor;
    if (healthPercentage > 0.7) {
      healthColor = '#4CAF50';
    } else if (healthPercentage > 0.3) {
      healthColor = '#FF9800';
    } else {
      healthColor = '#F44336';
    }
    
    ctx.fillStyle = healthColor;
    ctx.fillRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth * healthPercentage, 6);
    
    // Border
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 1;
    ctx.strokeRect(this.pos.x - healthBarWidth/2, this.pos.y - 25, healthBarWidth, 6);
    
    // Teks HP
    ctx.font = "10px sans-serif";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    
    let currentText, maxText;
    
    if (this.health >= 1000) {
      currentText = `${Math.floor(this.health/100)/10}k`;
    } else {
      currentText = `${Math.floor(this.health)}`;
    }
    
    if (this.maxHealth >= 1000) {
      maxText = `${Math.floor(this.maxHealth/100)/10}k`;
    } else {
      maxText = `${Math.floor(this.maxHealth)}`;
    }
    
    ctx.fillText(`${currentText}/${maxText}`, this.pos.x, this.pos.y - 10);
    
    // â­â­ TIDAK ADA INDIKATOR "READY"
  }
}

   class CircusSummon {
  constructor(x, y, type, hp) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.maxHealth = hp;
    this.health = hp;
    this.speed = 2.0;
    this.emoji = type;
    this.slowEffect = (type === "â›·ï¸");
  }
  
  update() {
    if (enemies.length === 0) return;
    
    // Cari musuh terdekat
    let target = null;
    let minDist = Infinity;
    
    enemies.forEach(e => {
      const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
      if (dist < minDist) {
        minDist = dist;
        target = e;
      }
    });
    
    if (target) {
      const dx = target.pos.x - this.x;
      const dy = target.pos.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      // Jika dalam jarak tabrakan (15px)
      if (dist < 15) {
        // â­â­ SISTEM TABRAK: Circus HP vs Musuh HP â­â­
        const enemyHP = target.health;
        
        // Musuh kehilangan HP = HP Circus
        target.takeDamage(this.health);
        
        // Circus kehilangan HP = HP Musuh
        this.health -= enemyHP;
        
        // Jika summon adalah salju, efek slow ke musuh sekitar
        if (this.slowEffect) {
          enemies.forEach(e => {
            if (Math.hypot(e.pos.x - this.x, e.pos.y - this.y) < 50) {
              e.slowUntil = Date.now() + 3000;
              e.slowMultiplier = 0.75;
            }
          });
        }
        
        // Cek jika Circus mati
        if (this.health <= 0) {
          const idx = summons.indexOf(this);
          if (idx !== -1) {
            summons.splice(idx, 1);
          }
        }
        
        // Cek jika musuh mati
        if (target.health <= 0) {
          const idx = enemies.indexOf(target);
          if (idx !== -1) {
            enemies.splice(idx, 1);
            money += 50;
          }
        }
        
        // â­â­ PERUBAHAN PENTING: KELUAR SETELAH TABRAKAN â­â­
        // Baik Circus mati atau tidak, KELUAR setelah 1x tabrakan
        // Ini sama seperti LoveSummon
        return;
      }
      
      // Bergerak ke target
      this.x += dx / dist * this.speed;
      this.y += dy / dist * this.speed;
    }
  }
  
  draw() {
    ctx.font = '24px serif';
    ctx.fillText(this.emoji, this.x, this.y);
    
    // Gambar aura efek slow untuk salju
    if (this.type === "â›·ï¸") {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 50, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(0, 200, 255, 0.2)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Health bar (jika masih hidup)
    if (this.health > 0) {
      const healthBarWidth = 40;
      const healthPercentage = this.health / this.maxHealth;
      
      // Background health bar
      ctx.fillStyle = '#000';
      ctx.fillRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth, 6);
      
      // Fill health bar berdasarkan jenis
      let healthColor;
      switch(this.type) {
        case "ğŸšµâ€â™€ï¸": healthColor = '#FF9800'; break; // oranye
        case "ğŸ§—â€â™‚ï¸": healthColor = '#4CAF50'; break; // hijau
        case "ğŸ„â€â™‚ï¸": healthColor = '#2196F3'; break; // biru
        case "â›·ï¸": healthColor = '#00BCD4'; break;  // cyan
        default: healthColor = '#FFFFFF';
      }
      
      ctx.fillStyle = healthColor;
      ctx.fillRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth * healthPercentage, 6);
      
      // Border health bar
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 1;
      ctx.strokeRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth, 6);
      
      // Teks HP
      ctx.font = '10px sans-serif';
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      
      // Format angka HP
      let currentText, maxText;
      
      if (this.health >= 1000) {
        currentText = `${Math.floor(this.health/100)/10}k`;
      } else {
        currentText = `${Math.floor(this.health)}`;
      }
      
      if (this.maxHealth >= 1000) {
        maxText = `${Math.floor(this.maxHealth/100)/10}k`;
      } else {
        maxText = `${Math.floor(this.maxHealth)}`;
      }
      
      ctx.fillText(`${currentText}/${maxText}`, this.x, this.y - 10);
    }
  }
}

     class VampireSummon {
  constructor(level){
    this.level = level;
    this.maxHealth = 200 + (50 * (level - 1)); // HP scaling per upgrade
    this.health = this.maxHealth;
    this.speed = 1.0;
    this.emoji = "ğŸ§Ÿâ€â™€ï¸";

    // posisi awal dari base (ujung path)
    if (Array.isArray(path[0])) {
      const p = path[0]; 
      this.pos = {...p[p.length - 1]};
      this.path = [...p].reverse();
    } else {
      this.pos = {...path[path.length - 1]};
      this.path = [...path].reverse();
    }
    this.pathIndex = 0;
  }

  update(){
    const next = this.path[this.pathIndex + 1];
    if(!next) {
      // sampai ke ujung â†’ hilang
      summons.splice(summons.indexOf(this), 1);
      return;
    }

    const dx = next.x - this.pos.x;
    const dy = next.y - this.pos.y;
    const dist = Math.hypot(dx, dy);

    if(dist < this.speed){
      this.pos = {...next};
      this.pathIndex++;
    } else {
      this.pos.x += dx / dist * this.speed;
      this.pos.y += dy / dist * this.speed;
    }

    for (let e of enemies){
      if(Math.hypot(e.pos.x - this.pos.x, e.pos.y - this.pos.y) < 20){
        e.takeDamage(20 + (5 * this.level)); // serangan standar
        this.health -= 20;

        if (e.health <= 0) {
          const idx = enemies.indexOf(e);
          if (idx !== -1) enemies.splice(idx, 1);
          money += 50; // ğŸ”¥ reward duit dari kill
        }

        if(this.health <= 0){
          summons.splice(summons.indexOf(this), 1);
        }
        break;
      }
    }
   }

  draw(){
    ctx.font = "24px serif";
    ctx.fillText(this.emoji, this.pos.x, this.pos.y);
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "white";
    ctx.fillText(`${this.health}`, this.pos.x, this.pos.y - 10);
  }
}
  
 // 1. Ubah class Barrier (sekitar baris 1869-1892):
class Barrier {
  constructor(x, y, health){
    this.x = x;
    this.y = y;
    this.maxHealth = health;
    this.health = health;
  }

  update(){
    // cek musuh yang nabrak barrier
    enemies.forEach(e => {
      const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
      if(dist < 20){ // tabrakan
        // SIMPAN HP MUSUH SEBELUM TABRAK
        const enemyHpBefore = e.health;
        
        // Musuh kehilangan HP = HP barrier saat ini
        e.takeDamage(this.health);
        
        // Barrier kehilangan HP = HP musuh sebelum tabrak
        this.health -= enemyHpBefore;
        
        // HAPUS FLOATING TEXT TRANSFER HP (KOMENTARI/ HAPUS)
        // floatingTexts.push({
        //   x: this.x,
        //   y: this.y - 20,
        //   text: `-${enemyHpBefore}HP`,
        //   alpha: 1,
        //   time: Date.now()
        // });
        // 
        // floatingTexts.push({
        //   x: e.pos.x,
        //   y: e.pos.y - 20,
        //   text: `-${this.health}HP`,
        //   alpha: 1,
        //   time: Date.now()
        // });
      }
    });

    if(this.health <= 0){
      barriers.splice(barriers.indexOf(this), 1);
      // Floating text barrier hancur (OPSIONAL, bisa dihapus juga)
      // floatingTexts.push({
      //   x: this.x,
      //   y: this.y - 20,
      //   text: `ğŸšª Hancur!`,
      //   alpha: 1,
      //   time: Date.now()
      // });
    }
  }

  draw(){
    ctx.font = '24px serif';
    ctx.fillText('ğŸšª', this.x, this.y);
    
    // Health bar untuk barrier
    const healthBarWidth = 30;
    const healthPercentage = this.health / this.maxHealth;
    
    // Background health bar
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth, 6);
    
    // Warna health bar
    if (healthPercentage > 0.7) {
      ctx.fillStyle = '#4CAF50'; // hijau
    } else if (healthPercentage > 0.3) {
      ctx.fillStyle = '#FF9800'; // oranye
    } else {
      ctx.fillStyle = '#F44336'; // merah
    }
    
    // Fill health bar
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth * healthPercentage, 6);
    
    // Border health bar
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 1;
    ctx.strokeRect(this.x - healthBarWidth/2, this.y - 25, healthBarWidth, 6);
    
    // Teks HP barrier (MASIH ADA)
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.floor(this.health)}/${this.maxHealth}`, this.x, this.y - 10);
  }
}

  class EngineerBarrier {
  constructor(x, y, level, owner) {
    this.x = x;
    this.y = y;
    this.level = level;
    this.owner = owner; // referensi ke insinyur yang memiliki barrier ini
    
    // Set stats berdasarkan level
    const hpMap = {1:200, 2:500, 3:1000, 4:2000, 5:5000};
    const allyDmgMap = {1:0, 2:0, 3:0, 4:0, 5:100};
    const allyRangeMap = {1:0, 2:0, 3:0, 4:0, 5:100};
    
    this.maxHealth = hpMap[level];
    this.health = this.maxHealth;
    this.allyDamage = allyDmgMap[level];
    this.allyRange = allyRangeMap[level];
    
    // Emoji berdasarkan level
    const emojiMap = {1:"ğŸ ", 2:"ğŸ¡", 3:"ğŸ¤", 4:"ğŸ¢", 5:"ğŸ°"};
    this.emoji = emojiMap[level];
    
    this.lastShot = 0;
    this.cooldown = 1000; // 1 detik untuk damage ally
  }

  update() {
    const now = Date.now();
    
    // ğŸ”¥ CEK TABRAKAN DENGAN MUSUH - DISAMAKAN DENGAN CLASS BARRIER
    enemies.forEach(e => {
      const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
      if(dist < 20){ // tabrakan
        // SIMPAN HP MUSUH SEBELUM TABRAK
        const enemyHpBefore = e.health;
        
        // Musuh kehilangan HP = HP barrier saat ini
        e.takeDamage(this.health);
        
        // Barrier kehilangan HP = HP musuh sebelum tabrak
        this.health -= enemyHpBefore;
        
        // TIDAK ADA FLOATING TEXT
        
        // Cek jika musuh mati
        if (e.health <= 0) {
          const idx = enemies.indexOf(e);
          if (idx !== -1) {
            enemies.splice(idx, 1);
            money += 50;
          }
        }
      }
    });

    // Level 5: bisa memberikan damage ke musuh dalam range
    if (this.level === 5 && this.allyDamage > 0 && now - this.lastShot >= this.cooldown) {
      enemies.forEach(e => {
        const dist = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
        if (dist < this.allyRange) {
          e.takeDamage(this.allyDamage);
          
          // TIDAK ADA FLOATING TEXT
          
          this.lastShot = now;
        }
      });
      
      // âŒ HAPUS EFEK VISUAL SERANGAN LEVEL 5
      // Efek visual serangan level 5 (DIHAPUS)
    }
    
    // ğŸ”¥ CEK APAKAH BARRIER HANCUR (HP <= 0)
    if(this.health <= 0){
      const idx = barriers.indexOf(this);
      if (idx !== -1) {
        barriers.splice(idx, 1);
        
        // Beri tahu insinyur bahwa barrier-nya hancur
        if (this.owner) {
          this.owner.hasBarrier = false;
          this.owner.barrierDestroyed = true;
          this.owner.barrierDestroyedTime = now;
          
          // âŒ TIDAK ADA FLOATING TEXT NOTIFIKASI
        }
      }
    }
  }

  draw() {
    ctx.font = '28px serif';
    ctx.fillText(this.emoji, this.x - 14, this.y + 14);
    
    // Health bar
    const healthBarWidth = 40;
    const healthPercentage = this.health / this.maxHealth;
    
    // Background health bar
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 30, healthBarWidth, 6);
    
    // Warna health bar berdasarkan level
    if (this.level === 5) {
      ctx.fillStyle = '#FFD700'; // emas untuk level 5
    } else {
      // Gradient berdasarkan persentase HP
      if (healthPercentage > 0.7) {
        ctx.fillStyle = '#4CAF50'; // hijau
      } else if (healthPercentage > 0.3) {
        ctx.fillStyle = '#FF9800'; // oranye
      } else {
        ctx.fillStyle = '#F44336'; // merah
      }
    }
    
    // Fill health bar
    ctx.fillRect(this.x - healthBarWidth/2, this.y - 30, healthBarWidth * healthPercentage, 6);
    
    // Border health bar
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 1;
    ctx.strokeRect(this.x - healthBarWidth/2, this.y - 30, healthBarWidth, 6);
    
    // Teks HP
    ctx.font = '10px sans-serif';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    
    let healthText;
    if (this.health >= 1000) {
      healthText = `${Math.floor(this.health/100)/10}k/${Math.floor(this.maxHealth/100)/10}k`;
    } else {
      healthText = `${Math.floor(this.health)}/${this.maxHealth}`;
    }
    ctx.fillText(healthText, this.x, this.y - 15);
    
    // âŒ HAPUS VISUAL RANGE DAN DAMAGE UNTUK LEVEL 5
    // Untuk level 5, gambar range lingkaran dan damage (DIHAPUS)
    
    // Tampilkan level
    ctx.font = '8px sans-serif';
    ctx.fillStyle = '#AAA';
    ctx.fillText(`Lv.${this.level}`, this.x, this.y + 25);
  }
}

   function getBarrierHP(level) {
  const hpMap = {1:200, 2:500, 3:1000, 4:2000, 5:5000};
  return hpMap[level];
}

   class Falcon {
  constructor(owner){
    this.owner = owner;
    this.pos = { x: owner.x, y: owner.y };
    this.speed = 2.5;
    this.damage = owner.damage;   // ikut damage Falconer
    this.target = null;
    this.alive = true;
    this.lastAttack = 0;          
    this.attackCD = 1000;         
  }

  update(){
    if (!this.alive) return;

    // cari target baru kalau gak ada / mati
    if (!this.target || this.target.health <= 0) {
      if (enemies.length > 0) {
        this.target = enemies.slice().sort((a,b)=>a.health - b.health)[0]; // HP terendah
      } else {
        this.target = null;
      }
    }

    if (this.target) {
      const dx = this.target.pos.x - this.pos.x;
      const dy = this.target.pos.y - this.pos.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 10) {
        const now = Date.now();
        if (now - this.lastAttack >= this.attackCD) {
          this.target.health -= this.damage;
          this.lastAttack = now;

          if (this.target.health <= 0) {
            const i = enemies.indexOf(this.target);
            if (i !== -1) enemies.splice(i, 1);
            money += 50;
            this.target = null;
          }
        }
      } else {
        // terbang menuju target
        this.pos.x += dx / dist * this.speed;
        this.pos.y += dy / dist * this.speed;
      }
    } else {
      // gak ada musuh â†’ balik ke Falconer
      const dx = this.owner.x - this.pos.x;
      const dy = this.owner.y - this.pos.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 5) {
        this.pos.x += dx / dist * this.speed;
        this.pos.y += dy / dist * this.speed;
      }
    }
  }

  draw(){
    if (!this.alive) return;
    ctx.font = '24px serif';
    ctx.fillText('ğŸ¦…', this.pos.x, this.pos.y);
  }
}
   
    function closestPointsOnPathWithinRange(x, y, range){
  const pts = [];

  // bikin daftar semua path (kalau multi-jalur, flatten jadi banyak path)
  const pathsToCheck = Array.isArray(path[0]) ? path : [path];

  pathsToCheck.forEach(p => {
    for(let i=0; i<p.length-1; i++){
      const p1 = p[i], p2 = p[i+1];
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const len2 = dx*dx + dy*dy;
      if(len2 === 0) continue;

      // cari proyeksi titik (x,y) ke segmen path
      let t = ((x - p1.x) * dx + (y - p1.y) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const cx = p1.x + t*dx;
      const cy = p1.y + t*dy;

      if(Math.hypot(cx - x, cy - y) <= range){
        pts.push({x: cx, y: cy});
      }
    }
  });

  return pts;
}

    function isOnPath(x, y) {
  const pathsToCheck = Array.isArray(path[0]) ? path : [path];
  for (let p of pathsToCheck) {
    for (let i = 0; i < p.length - 1; i++) {
      const p1 = p[i], p2 = p[i+1];
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const len2 = dx*dx + dy*dy;
      if (len2 === 0) continue;

      // cari titik terdekat ke segmen
      let t = ((x - p1.x) * dx + (y - p1.y) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const cx = p1.x + t * dx;
      const cy = p1.y + t * dy;

      // kalau terlalu deket sama path â†’ dianggap di path
      if (Math.hypot(cx - x, cy - y) < 25) {
        return true;
      }
    }
  }
  return false;
}

    function selectUnitType(type){
  selectedType = type;
  selectedUnit = null;
  document.getElementById('unitInfo').innerText = 'Klik unit untuk info';
  document.getElementById('upgradeCost').innerText = 'Harga Upgrade: -';
  
  // Reset tombol upgrade ke tampil normal
  document.getElementById('upgradeBtn').classList.remove('hidden');
}

   canvas.addEventListener('click', e => {
  const x = e.offsetX, y = e.offsetY;
  const found = towers.find(t => Math.hypot(t.x - x, t.y - y) < 20);

  if (found) {
    // --- Klik tower (tampil info, upgrade cost, dll) ---
    selectedUnit = found;
    document.getElementById('unitInfo').innerText =
      `Level ${found.level} ${found.emoji} - Dmg ${found.damage}`;

   // ğŸ”¥ Handle tombol khusus untuk tower tertentu
const timeStopBtn = document.getElementById('timeStopBtn');
const consoleShootBtn = document.getElementById('consoleShootBtn');

// Reset semua tombol khusus dulu
timeStopBtn.style.display = 'none';
consoleShootBtn.style.display = 'none';
activeConsole = null;

// Tampilkan tombol yang sesuai dengan tower type
if (found.type === "clock") {
  // Tampilkan tombol Time Stop
  timeStopBtn.style.display = 'inline-block';
  
  // Update cooldown display
  const remainingCD = Math.max(0, clockSkillCooldown - Date.now());
  
  if (remainingCD > 0) {
    const seconds = Math.ceil(remainingCD / 1000);
    timeStopBtn.innerText = `â° CD: ${seconds}s`;
    timeStopBtn.disabled = true;
    timeStopBtn.style.background = '#666';
  } else {
    timeStopBtn.innerText = 'â° Time Stop';
    timeStopBtn.disabled = false;
    timeStopBtn.style.background = '#0066cc';
  }
} 
else if (found.type === "console") {
  // Tampilkan tombol Console Shoot
  consoleShootBtn.style.display = 'inline-block';
  activeConsole = found; // Set sebagai console aktif
  
  // Update cooldown display jika ada
  const remainingCD = Math.max(0, consoleCooldown - Date.now());
  
  if (remainingCD > 0) {
    const seconds = Math.ceil(remainingCD / 1000);
    consoleShootBtn.innerText = `âœ´ï¸ CD: ${seconds}s`;
    consoleShootBtn.disabled = true;
    consoleShootBtn.style.background = '#666';
  } else {
    consoleShootBtn.innerText = 'âœ´ï¸ Tembak Console';
    consoleShootBtn.disabled = false;
    consoleShootBtn.style.background = '#9C27B0';
  }
  
  // Update info khusus console
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ${found.emoji} - Dmg ${found.damage} - Range ${found.range}`;
}

// ğŸ”¥ Sembunyikan tombol upgrade untuk Bitcoin, Circus, dan Astronaut
const upgradeBtn = document.getElementById('upgradeBtn');
if (found.type === "bitcoin" || found.type === "circus" || found.type === "astronaut") {
    upgradeBtn.classList.add('hidden');
} else {
    upgradeBtn.classList.remove('hidden');
}

    if (found.type === "cupid") {
      const upgradeCosts = [0, 300, 450, 600];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

    } else if (found.type === "bombi") {
      const upgradeCosts = [0, 500, 1000, 2000, 3000];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

    } else if (found.type === "chef") {
      const upgradeCosts = [0, 200, 400, 800];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

    } else if (found.type === "sniper") {
      const upgradeCosts = [0, 300, 900, 1500];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

   } else if (found.type === "ball") {
      const upgradeCosts = [0, 250, 400, 700, 1200];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

   } else if (found.type === "console") {
  const upgradeCosts = [0, 600, 750, 900, 1200];
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

   } else if (found.type === "police") {
      const upgradeCosts = [0, 750, 1000, 1600, 2500];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

   } else if (found.type === "colors") {
  const upgradeCosts = [0, 600, 1000, 1500, 2000];
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ${found.emoji} - Dmg ${found.damage} | CD ${found.cooldown/1000}s | Range ${found.range}`;
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;
 
   } else if (selectedUnit.type === "homesweet") {
  const upgradeCosts = [0, 1200, 2500, 3000];
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${selectedUnit.level < 4 ? upgradeCosts[selectedUnit.level] : 'Maks'}`;

} else if (found.type === "star") {
  const upgradeCosts = [0, 500, 750];
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} â­ Star | Dmg ${found.damage}`; // âœ… AMMO DIHAPUS
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 3 ? upgradeCosts[found.level] : 'Maks'}`;

       } else if (found.type === "swordwrath") {
      const upgradeCosts = [0, 500, 750, 1000];
      document.getElementById('unitInfo').innerText =
        `Level ${found.level} ${found.emoji} - Dmg ${found.damage} - CD ${found.cooldown/1000}s`;
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

       } else if (found.type === "neptun") {
      const upgradeCosts = [0, 800, 1650, 2500, 3200];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

        } else if (found.type === "clock") {
      const upgradeCosts = [0, 900, 1750];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 3 ? upgradeCosts[found.level] : 'Maks'}`;

        } else if (found.type === "capaw") {
  const upgradeCosts = [0, 200, 500, 750, 1250];
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

       } else if (found.type === "cinema") {
  const upgradeCosts = [0, 800, 1400, 2000];
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ${found.emoji} - Dmg ${found.damage} | Range ${found.range} | 5% Stun 5s`;
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

       } else if (found.type === "kompas") {
  const upgradeCosts = [0, 600, 1000, 1250];
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ${found.emoji} - Dmg ${found.damage} - CD ${found.cooldown/1000}s`;
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

} else if (found.type === "bitcoin") {
  const timeAlive = Math.floor((Date.now() - found.createdAt) / 1000);
  document.getElementById('unitInfo').innerText =
    `ğŸª™ Bitcoin | Nilai jual: ${found.sellValue} | Waktu hidup: ${timeAlive}s`;
  document.getElementById('upgradeCost').innerText = ``;

} else if (found.type === "camera") {
  const upgradeCosts = [0, 800, 1500, 2500];
  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ğŸ“· Camera | Copy: ${found.copiedFrom || 'None'}`;
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 4 ? upgradeCosts[found.level] : 'Maks'}`;

} else if (found.type === "laser") {
  const upgradeCosts = [0, 600, 900, 1200, 1500];
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

} else if (found.type === "hook") {
  const upgradeCosts = [0, 800, 1500, 2500, 4000];
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

} else if (found.type === "insinyur") {
  const upgradeCosts = [0, 400, 600, 1000, 2000];
  const barrierHP = getBarrierHP(found.level);

  document.getElementById('unitInfo').innerText =
    `Level ${found.level} ğŸ‘· Insinyur | Barrier HP: ${barrierHP}`;
  document.getElementById('upgradeCost').innerText =
    `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;
  
  // Reset tombol upgrade ke tampil normal
  document.getElementById('upgradeBtn').classList.remove('hidden');

      } else if (found.type === "plant") {
      const upgradeCosts = [0, 500, 1500, 2000, 3000];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

      } else if (found.type === "koboi") {
      const upgradeCosts = [0, 450, 900, 1750, 2600];
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? upgradeCosts[found.level] : 'Maks'}`;

    } else {
      document.getElementById('upgradeCost').innerText =
        `Harga Upgrade: ${found.level < 5 ? 100 * found.level : 'Maks'}`;
       }

      if (selectedUnit.type === "neptun") {
  // toggle mode
  selectedUnit.mode = (selectedUnit.mode === "neptun") ? "jin" : "neptun";
  selectedUnit.emoji = (selectedUnit.mode === "neptun") ? "ğŸ§œâ€â™‚ï¸" : "ğŸ§â€â™‚ï¸";
  document.getElementById('unitInfo').innerText = 
    `Mode: ${selectedUnit.mode} | Dmg ${selectedUnit.damage}`;
    }

  } else {
    selectedUnit = null;
    document.getElementById('unitInfo').innerText = 'Klik unit untuk info';
    document.getElementById('upgradeCost').innerText = 'Harga Upgrade: -';

  // Reset tombol upgrade ke tampil normal
document.getElementById('upgradeBtn').classList.remove('hidden');

    const costMap = { 
  sword:150, archer:200, speaker:300, chef:450, 
  sniper:250, lovers:400, scientist:550, timemage:900, 
  falconer:350, programmer:750, farmer:150, cupid:200, 
  boost:300, bombi:600, judi:555, priest:400, vampire:700, 
  ball:300, god:3000, neptun:1250, koboi:550, capaw:350, 
  printer:300, laser:500, satellite:100, police:600, wrench:800, plant:150, dadu:900, bitcoin:500, 
  hook:750, circus:5000, clock:650, console:500, astronaut:800, homesweet:1000, camera:1500, 
  swordwrath:400, kompas:500, colors:300, cinema:600, star:400, insinyur:300
};

    const cost = costMap[selectedType];

    // âœ… Tambahkan limit farmer di sini
    if (selectedType === "farmer") {
      const farmerCount = towers.filter(t => t.type === "farmer").length;
      if (farmerCount >= 6) {
        alert("Maksimal 6 Farmer!");
        return;
      }
    }

    if (selectedType === "priest") {
  const priestCount = towers.filter(t => t.type === "priest").length;
  if (priestCount >= 5) {
    alert("Maksimal 5 Priest!");
    return;
  }
}

     if (selectedType === "insinyur") {
  const insinyurCount = towers.filter(t => t.type === "insinyur").length;
  if (insinyurCount >= 2) {
    alert("ğŸ‘·Insinyur hanya bisa di pasang 2!");
    return;
  }
}

    if (selectedType === "bitcoin") {
  const bitcoinCount = towers.filter(t => t.type === "bitcoin").length;
  if (bitcoinCount >= 5) {
    alert("Maksimal 5 Bitcoin!");
    return;
  }
}

    if (selectedType === "wrench") {
  const wrenchCount = towers.filter(t => t.type === "wrench").length;
  if (wrenchCount >= 5) {
    alert("Maksimal 5 Wrench!");
    return;
  }
}

    if (selectedType === "vampire") {
      const vampireCount = towers.filter(t => t.type === "vampire").length;
      if (vampireCount >= 4) {
        alert("Maksimal 4 Vampire!");
        return;
      }
    }

    if (selectedType === "astronaut") {
      const astronautCount = towers.filter(t => t.type === "astronaut").length;
      if (astronautCount >= 12) {
        alert("Maksimal 12 Astronaut!");
        return;
      }
    }

    if (selectedType === "camera") {
      const cameraCount = towers.filter(t => t.type === "camera").length;
      if (cameraCount >= 3) {
        alert("Maksimal 3 Camera ğŸ“·");
        return;
      }
    }

    if (selectedType === "scientist") {
      const scientistCount = towers.filter(t => t.type === "scientist").length;
      if (scientistCount >= 3) {
        alert("Maksimal 3 Scientist!");
        return;
      }
    }

if (selectedType === "god") {
  const godCount = towers.filter(t => t.type === "god").length;
  if (godCount >= 1) {
    alert("ğŸª¬ God cuma bisa dipasang 1 kali!");
    return;
  }
}

 if (selectedType === "printer") {
  const printerCount = towers.filter(t => t.type === "printer").length;
  if (printerCount >= 3) {
    alert("Maksimal 3 Printer!");
    return;
  }
}

 if (selectedType === "dadu") {
  const daduCount = towers.filter(t => t.type === "dadu").length;
  if (daduCount >= 4) {
    alert("Maksimal 4 Dadu!");
    return;
  }
}

  if (selectedType === "circus") {
  const circusCount = towers.filter(t => t.type === "circus").length;
  if (circusCount >= 2) {
    alert("Maksimal 2 Circus!");
    return;
  }
}

   if (selectedType === "hook") {
  const hookCount = towers.filter(t => t.type === "hook").length;
  if (hookCount >= 20) {
    alert("Maksimal 20 Hook!");
    return;
  }
}

    if (isOnPath(x, y)) {
  const now = Date.now();
  if (now - lastPathWarning > 1500) {   // cuma muncul sekali tiap 1.5 detik
    showNotification("ğŸš· Tidak bisa pasang di jalan musuh!");
    lastPathWarning = now;
  }
  return;
}
 
    if (cost && money >= cost) {
      money -= cost;
      towers.push(new Tower(x, y, selectedType));
    }
  }
});

    document.getElementById('upgradeBtn').onclick = () => {
      if(selectedUnit) selectedUnit.upgrade();
    };

    function showNotification(msg) {
  const container = document.getElementById("notificationContainer");
  const div = document.createElement("div");
  div.innerText = msg;
  div.style.marginTop = "5px";
  div.style.opacity = "1";
  div.style.transition = "opacity 1s ease-out";
  container.appendChild(div);

  // hilangkan setelah 2.5 detik
  setTimeout(() => {
    div.style.opacity = "0";
    setTimeout(() => div.remove(), 1000);
  }, 2500);
}

    function spawnWave(){
  spawning = true;

  if (Math.random() < NIGHT_CHANCE) {
    enableNightMode();
  }

  if(endlessMode){
    score = wave; // skor = wave yang ditempuh
  }

  // jumlah musuh per wave (endless lebih banyak)
  const count = endlessMode ? wave * 2 : (wave <= 10 ? wave : wave * 2);

  // bonus dari farmer
const farmers = towers.filter(t => t.type === 'farmer');
if (farmers.length > 0) {
  let totalGain = 0;
  farmers.forEach(f => {
    // Income per wave berdasarkan level: 50 / 100 / 150 / 200 / 250
    const incomeMap = {1:50, 2:100, 3:150, 4:200, 5:250};
    totalGain += incomeMap[f.level] || 50;
  });
  money += totalGain;
  showNotification(`ğŸ‘¨â€ğŸŒ¾ Farmer mengumpulkan ${totalGain} money!`);
}

  // bonus dari priest
const priests = towers.filter(t => t.type === 'priest');
if (priests.length > 0) {
  let totalHeal = 0;
  priests.forEach(p => totalHeal += 20); // tiap priest heal +20
  baseHP = Math.min(500, baseHP + totalHeal); // base max 500
  showNotification(`â›ª Priest menyembuhkan base +${totalHeal} HP!`);
}

  // pool musuh biasa
  const pool = ['zombie','ghost'];
  if (wave >= 6) pool.push('angry');
  if (wave >= 9) pool.push('ninja');
  if (wave >= 11) pool.push('shield');
  if (wave >= 13) pool.push('furry');
  if (wave >= 15) pool.push('thief');
  if (wave >= 17) pool.push('engineer');
  if (wave >= 19) pool.push('dancing');
  if (wave >= 20) pool.push('reog');
  if (wave >= 22) pool.push('luckyblock');
  if (wave >= 24) pool.push('hearts');
  if (wave >= 26) pool.push('speedrun');
  if (wave >= 28) pool.push('healer');
  if (wave >= 30) pool.push('guru');
  if (wave >= 32) pool.push('las');
  if (wave >= 34) pool.push('art');
  if (wave >= 36) pool.push('liar');
  if (wave >= 38) pool.push('necro');
  if (wave >= 38) pool.push('santa');
  if (wave >= 38) pool.push('nerd');
  if (wave >= 40) pool.push('snow');
  if (wave >= 40) pool.push('alien');
  if (wave >= 42) pool.push('static');
  if (wave >= 42) pool.push('toilet');
  if (wave >= 44) pool.push('posaidon'); 
  if (wave >= 46) pool.push('duke');
  if (wave >= 48) pool.push('ufo');
  if (wave >= 60) pool.push('nuklir');

  // ğŸ‰ Boss setiap 10 wave (khusus endless)
  if (endlessMode && wave % 10 === 0) {
    const boss = new Enemy("boss");
    boss.maxHealth = 5000 + wave * 500; // scaling darah
    boss.health = boss.maxHealth;
    boss.speed = 0.5 + (wave * 0.01);
    boss.emoji = "ğŸ‰"; // emoji boss
    enemies.push(boss);
    showNotification(`âš ï¸ Boss muncul di Wave ${wave}!`);
  }

  // spawn musuh biasa
  for (let i = 0; i < count; i++) {
    setTimeout(() => {
      const enemyType = pool[Math.floor(Math.random() * pool.length)];
      const enemy = new Enemy(enemyType);

      if (nightMode) {
        enemy.speed *= 2;
      }

      if (endlessMode) {
        enemy.health += wave * 10;
        enemy.maxHealth += wave * 10;
        enemy.speed *= 1 + (wave * 0.01);
      }

      enemies.push(enemy);
      if (i === count - 1) spawning = false;
    }, i * 500);
  }

  document.getElementById('waveCounter').innerText = 'Wave: ' + wave;
  wave++;
}
  document.getElementById('menuBtn').onclick = () => {
  document.getElementById('winScreen').style.display = 'none';
  gameArea.style.display = 'none';
  menu.style.display = 'flex';
  // reset state game (kecuali diamond biar tetep nyimpen)
  baseHP = 500;
  wave = 1;
  money = 300;
  enemies.length = 0;
  towers.length = 0;
  bullets.length = 0;
  summons.length = 0;
  barriers.length = 0;
  spawning = false;
};

     function startGame(mapName, mode){
  unitMode = mode || "all"; // simpan pilihan mode
  document.getElementById("mapSelect").style.display = "none";
  document.getElementById("gameArea").style.display = "block";
  menu.style.display = "none";

  path = maps[mapName];

const retryBtn = document.getElementById('retryBtn');
retryBtn.onclick = () => {
  retryScreen.style.display = 'none';
  gameArea.style.display = 'none';
  menu.style.display = 'flex';
  baseHP = 500;
  wave = 1;
  money = 300;
  enemies.length = 0;
  towers.length = 0;
  bullets.length = 0;
  summons.length = 0;
  barriers.length = 0;
  mirrors.length = 0; // Hapus semua mirror saat game restart
  spawning = false;
};

const menuBtn = document.getElementById('menuBtn');
menuBtn.onclick = () => {
  document.getElementById('winScreen').style.display = 'none';
  gameArea.style.display = 'none';
  menu.style.display = 'flex';
  baseHP = 500;
  wave = 1;
  money = 300;
  enemies.length = 0;
  towers.length = 0;
  bullets.length = 0;
  summons.length = 0;
  barriers.length = 0;
  spawning = false;
};

const hotbar = document.getElementById("hotbar");
const toggleBtn = document.getElementById("toggleHotbarBtn");

toggleBtn.addEventListener("click", () => {
  hotbar.classList.toggle("collapsed");
  toggleBtn.textContent = hotbar.classList.contains("collapsed") ? "ğŸ”¼" : "ğŸ”½";
});

 function resetGame() {
  retryScreen.style.display = 'none';
  gameArea.style.display = 'none';
  menu.style.display = 'flex';
  baseHP = 500;
  wave = 1;
  money = 300;
  enemies.length = 0;
  towers.length = 0;
  bullets.length = 0;
  summons.length = 0;
  lifts.length = 0;
  barriers.length = 0;
  mirrors.length = 0; 
  spawning = false;
  
  
  // === TAMBAHKAN DI SINI (DI AKHIR FUNGSI) ===
  // Reset efek poop di semua tower
  towers.forEach(tower => {
    if (tower.originalCooldown) {
      tower.cooldown = tower.originalCooldown;
      delete tower.originalCooldown;
    }
  });
}

retryBtn.onclick = resetGame;

  spawnWave();
  gameLoop();
}

    function moveBullets(){
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    // ğŸ”¥ khusus Capaw (boomerang)
if (b.from && b.from.type === "capaw") {
  if (!b.hitForward) b.hitForward = new Set();
  if (!b.hitBackward) b.hitBackward = new Set();

  if (!b.returning) {
    // gerak maju
    b.x += 8;
    b.traveled += 8;
    if (b.traveled >= b.range) {
      b.returning = true; // mulai balik
    }

    // cek hit ke musuh (fase maju, sekali saja per musuh)
    enemies.forEach(e => {
      if (!b.hitForward.has(e) && Math.hypot(e.pos.x - b.x, e.pos.y - b.y) < 15) {
        e.takeDamage(b.damage);   // dmg maju
        b.hitForward.add(e);      // tandai udah kena
      }
    });

  } else {
    // gerak balik
    const dx = b.from.x - b.x;
    const dy = b.from.y - b.y;
    const d = Math.hypot(dx, dy);
    if (d > 0) {
      b.x += dx / d * 8;
      b.y += dy / d * 8;
    }
    if (d < 10) {
      bullets.splice(i, 1);
      continue;
    }

    // cek hit ke musuh (fase balik, sekali saja per musuh)
    enemies.forEach(e => {
      if (!b.hitBackward.has(e) && Math.hypot(e.pos.x - b.x, e.pos.y - b.y) < 15) {
        e.takeDamage(b.damage);   // dmg balik
        b.hitBackward.add(e);     // tandai udah kena
      }
    });
  }

  // gambar boomerang
  ctx.beginPath();
  ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = "orange";
  ctx.fill();
  continue;
}

// ğŸŸ¢ CODE BARU - Star TANPA FLOATING TEXT
if (b.type === 'star') {
  const dx = b.target.pos.x - b.x;
  const dy = b.target.pos.y - b.y;
  const d = Math.hypot(dx, dy);
  
  if (d > 0) {
    b.x += dx / d * 10;
    b.y += dy / d * 10;
  }
  
  // Gambar peluru bintang dengan efek glow
  ctx.font = '20px serif';
  ctx.fillStyle = '#FFD700';
  ctx.shadowColor = '#FF8C00';
  ctx.shadowBlur = 12;
  ctx.fillText('â˜€', b.x - 10, b.y + 8);
  ctx.shadowBlur = 0;
  
  // Efek trail kecil
  ctx.beginPath();
  ctx.arc(b.x - 5, b.y - 5, 3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
  ctx.fill();
  
  // CEK TABRAKAN DAN BERIKAN DAMAGE
  if (d < 15) {
    // Berikan damage ke target
    b.target.takeDamage(b.damage);
    
    // âŒ FLOATING TEXT DIHAPUS (tidak ada floating text)
    
    // Hapus peluru
    bullets.splice(i, 1);
    
    // Cek apakah musuh mati setelah damage
    if (b.target.health <= 0) {
      const idx = enemies.indexOf(b.target);
      if (idx !== -1) {
        enemies.splice(idx, 1);
        money += 50;
      }
    }
  }
  continue;
}

// ğŸ¬ Cinema bullet - billiard ball
if (b.type === 'cinema') {
  const dx = b.target.pos.x - b.x;
  const dy = b.target.pos.y - b.y;
  const d = Math.hypot(dx, dy);
  if (d > 0) {
    b.x += dx / d * 8;
    b.y += dy / d * 8;
  }
  
  // Gambar peluru billiard
  ctx.font = '20px serif';
  ctx.fillText('ğŸ±', b.x - 10, b.y + 8);
  
  // Efek trail
  ctx.beginPath();
  ctx.arc(b.x - 2, b.y - 2, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fill();
  
  if (d < 8) {
    bullets.splice(i, 1);
  }
  continue;
}

    // ===== PELURU KOMPAS (4 ARAH LURUS) =====
if (b.type === 'kompas') {
  // Gerak lurus
  b.x += b.vx;
  b.y += b.vy;
  b.traveled += Math.hypot(b.vx, b.vy);

  // Gambar peluru
  ctx.beginPath();
  ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#FFD700'; // emas
  ctx.shadowColor = '#FFA500';
  ctx.shadowBlur = 8;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Cek tabrakan dengan musuh (TANPA FLOATING TEXT)
  enemies.forEach(e => {
    if (!b.hitEnemies.has(e) && Math.hypot(e.pos.x - b.x, e.pos.y - b.y) < 20) {
      e.takeDamage(b.damage);
      b.hitEnemies.add(e); // Tandai sudah kena
      // âŒ TIDAK ADA FLOATING TEXT
    }
  });

  // Hapus jika mencapai batas jarak
  if (b.traveled >= b.maxTravel) {
    bullets.splice(i, 1);
  }
  continue;
}

    // ğŸ”« default bullet (tower biasa)
    const dx = b.target.pos.x - b.x;
    const dy = b.target.pos.y - b.y;
    const d = Math.hypot(dx, dy);
    if (d > 0) {
      b.x += dx / d * 6;
      b.y += dy / d * 6;
    }
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5, 0, 2 * Math.PI);
    ctx.fillStyle = "yellow"; // default tower bullet warna kuning
    ctx.fill();

    if (d < 5) {
      b.target.takeDamage(b.damage);
      if (b.splash) {
        enemies.forEach(e => {
          if (e !== b.target && Math.hypot(e.pos.x - b.target.pos.x, e.pos.y - b.target.pos.y) < 30) {
            e.takeDamage(b.damage / 2);
          }
        });
      }
      bullets.splice(i, 1);
    }
  }
}

    function drawBullets(){
  for (let b of bullets){
    if (b.from && b.from.type === "capaw") {
      // ğŸªƒ Capaw boomerang warna hijau
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(b.x, b.y, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

    function gameLoop(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPath();
  
  // â° NOMOR 11: Visual effect Time Stop
  if (timeStopActive && Date.now() < timeStopEnd) {
    // Overlay biru transparan
    ctx.fillStyle = 'rgba(0, 100, 255, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Countdown timer
    const remaining = Math.ceil((timeStopEnd - Date.now()) / 1000);
    ctx.font = '30px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(`â° ${remaining}s`, canvas.width / 2, 50);
  }
  
  enemies.forEach(e => { e.update(); e.draw(); });
  towers.forEach(t => { t.update(); t.draw(); });
  moveBullets();
  drawBullets();
  summons.forEach(s => { s.update(); s.draw(); });
  lifts.forEach(l => { l.update(); l.draw(); });
  barriers.forEach(b => { b.update(); b.draw(); });
  mirrors.forEach(m => { m.update(); m.draw(); });
  floatingTexts.forEach((ft, i) => {
    ctx.globalAlpha = ft.alpha;
    ctx.fillStyle = "lime";
    ctx.font = "16px sans-serif";
    ctx.fillText(ft.text, ft.x, ft.y);
    ctx.globalAlpha = 1.0;

    ft.y -= 0.5;
    ft.alpha -= 0.01;
    if (ft.alpha <= 0) floatingTexts.splice(i,1);
  });

  document.getElementById('baseInfo').innerText = `Base: ${baseHP}/500`;
  document.getElementById('moneyInfo').innerText = `Money: ${money}`;

  if(baseHP <= 0){
  if(endlessMode){
  if(score > highScore){
    highScore = score;
    localStorage.setItem("endlessHighScore", highScore);
    alert("ğŸ”¥ Rekor Baru! Wave " + highScore);
  } else {
    alert("Game Over! Wave: " + score + " | High Score: " + highScore);
  }
}
    retryScreen.style.display = 'flex';
    return;
  }

  if (enemies.length === 0 && !spawning) {
  if (nightMode) {
    disableNightMode();
  }

  if (!endlessMode && wave > 50) {
  addDiamonds(100);
  document.getElementById('winScreen').style.display = 'flex';
  checkWinAchievements(); // Tambahkan ini
  return;
}
  spawnWave();
}

  requestAnimationFrame(gameLoop);
}

  </script>
</body>
</html>